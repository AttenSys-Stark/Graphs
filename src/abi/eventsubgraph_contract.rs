// ****
// Auto-generated by cainome do not edit.
// ****

#[derive(Debug)]
pub struct eventsubgraph<A: starknet::accounts::ConnectedAccount + Sync> {
    pub address: starknet::core::types::Felt,
    pub account: A,
    pub block_id: starknet::core::types::BlockId,
}
impl<A: starknet::accounts::ConnectedAccount + Sync> eventsubgraph<A> {
    pub fn new(address: starknet::core::types::Felt, account: A) -> Self {
        Self {
            address,
            account,
            block_id: starknet::core::types::BlockId::Tag(
                starknet::core::types::BlockTag::Pending,
            ),
        }
    }
    pub fn set_contract_address(&mut self, address: starknet::core::types::Felt) {
        self.address = address;
    }
    pub fn provider(&self) -> &A::Provider {
        self.account.provider()
    }
    pub fn set_block(&mut self, block_id: starknet::core::types::BlockId) {
        self.block_id = block_id;
    }
    pub fn with_block(self, block_id: starknet::core::types::BlockId) -> Self {
        Self { block_id, ..self }
    }
}
#[derive(Debug)]
pub struct eventsubgraphReader<P: starknet::providers::Provider + Sync> {
    pub address: starknet::core::types::Felt,
    pub provider: P,
    pub block_id: starknet::core::types::BlockId,
}
impl<P: starknet::providers::Provider + Sync> eventsubgraphReader<P> {
    pub fn new(address: starknet::core::types::Felt, provider: P) -> Self {
        Self {
            address,
            provider,
            block_id: starknet::core::types::BlockId::Tag(
                starknet::core::types::BlockTag::Pending,
            ),
        }
    }
    pub fn set_contract_address(&mut self, address: starknet::core::types::Felt) {
        self.address = address;
    }
    pub fn provider(&self) -> &P {
        &self.provider
    }
    pub fn set_block(&mut self, block_id: starknet::core::types::BlockId) {
        self.block_id = block_id;
    }
    pub fn with_block(self, block_id: starknet::core::types::BlockId) -> Self {
        Self { block_id, ..self }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct AdminOwnershipClaimed {
    pub new_admin: cainome::cairo_serde::ContractAddress,
}
impl cainome::cairo_serde::CairoSerde for AdminOwnershipClaimed {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.new_admin,
            );
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(&__rust.new_admin),
            );
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let new_admin = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&new_admin);
        Ok(AdminOwnershipClaimed { new_admin })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct AdminTransferred {
    pub old_admin: cainome::cairo_serde::ContractAddress,
    pub new_admin: cainome::cairo_serde::ContractAddress,
}
impl cainome::cairo_serde::CairoSerde for AdminTransferred {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.old_admin,
            );
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.new_admin,
            );
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(&__rust.old_admin),
            );
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(&__rust.new_admin),
            );
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let old_admin = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&old_admin);
        let new_admin = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&new_admin);
        Ok(AdminTransferred {
            old_admin,
            new_admin,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct AttendanceMarked {
    pub event_identifier: cainome::cairo_serde::U256,
    pub attendee: cainome::cairo_serde::ContractAddress,
}
impl cainome::cairo_serde::CairoSerde for AttendanceMarked {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += cainome::cairo_serde::U256::cairo_serialized_size(
                &__rust.event_identifier,
            );
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.attendee,
            );
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out
            .extend(
                cainome::cairo_serde::U256::cairo_serialize(&__rust.event_identifier),
            );
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(&__rust.attendee),
            );
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let event_identifier = cainome::cairo_serde::U256::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::U256::cairo_serialized_size(&event_identifier);
        let attendee = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&attendee);
        Ok(AttendanceMarked {
            event_identifier,
            attendee,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct AttendeeInfo {
    pub attendee_address: cainome::cairo_serde::ContractAddress,
    pub attendee_uri: cainome::cairo_serde::ByteArray,
}
impl cainome::cairo_serde::CairoSerde for AttendeeInfo {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.attendee_address,
            );
        __size
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(
                &__rust.attendee_uri,
            );
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    &__rust.attendee_address,
                ),
            );
        __out
            .extend(
                cainome::cairo_serde::ByteArray::cairo_serialize(&__rust.attendee_uri),
            );
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let attendee_address = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &attendee_address,
            );
        let attendee_uri = cainome::cairo_serde::ByteArray::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(&attendee_uri);
        Ok(AttendeeInfo {
            attendee_address,
            attendee_uri,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct BatchCertificationCompleted {
    pub event_identifier: cainome::cairo_serde::U256,
    pub certified_attendees: Vec<cainome::cairo_serde::ContractAddress>,
}
impl cainome::cairo_serde::CairoSerde for BatchCertificationCompleted {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += cainome::cairo_serde::U256::cairo_serialized_size(
                &__rust.event_identifier,
            );
        __size
            += Vec::<
                cainome::cairo_serde::ContractAddress,
            >::cairo_serialized_size(&__rust.certified_attendees);
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out
            .extend(
                cainome::cairo_serde::U256::cairo_serialize(&__rust.event_identifier),
            );
        __out
            .extend(
                Vec::<
                    cainome::cairo_serde::ContractAddress,
                >::cairo_serialize(&__rust.certified_attendees),
            );
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let event_identifier = cainome::cairo_serde::U256::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::U256::cairo_serialized_size(&event_identifier);
        let certified_attendees = Vec::<
            cainome::cairo_serde::ContractAddress,
        >::cairo_deserialize(__felts, __offset)?;
        __offset
            += Vec::<
                cainome::cairo_serde::ContractAddress,
            >::cairo_serialized_size(&certified_attendees);
        Ok(BatchCertificationCompleted {
            event_identifier,
            certified_attendees,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct EventCreated {
    pub event_identifier: cainome::cairo_serde::U256,
    pub event_name: cainome::cairo_serde::ByteArray,
    pub event_organizer: cainome::cairo_serde::ContractAddress,
    pub event_uri: cainome::cairo_serde::ByteArray,
}
impl cainome::cairo_serde::CairoSerde for EventCreated {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += cainome::cairo_serde::U256::cairo_serialized_size(
                &__rust.event_identifier,
            );
        __size
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(
                &__rust.event_name,
            );
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.event_organizer,
            );
        __size
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(&__rust.event_uri);
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out
            .extend(
                cainome::cairo_serde::U256::cairo_serialize(&__rust.event_identifier),
            );
        __out
            .extend(
                cainome::cairo_serde::ByteArray::cairo_serialize(&__rust.event_name),
            );
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    &__rust.event_organizer,
                ),
            );
        __out
            .extend(cainome::cairo_serde::ByteArray::cairo_serialize(&__rust.event_uri));
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let event_identifier = cainome::cairo_serde::U256::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::U256::cairo_serialized_size(&event_identifier);
        let event_name = cainome::cairo_serde::ByteArray::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::ByteArray::cairo_serialized_size(&event_name);
        let event_organizer = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &event_organizer,
            );
        let event_uri = cainome::cairo_serde::ByteArray::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::ByteArray::cairo_serialized_size(&event_uri);
        Ok(EventCreated {
            event_identifier,
            event_name,
            event_organizer,
            event_uri,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct EventEnded {
    pub event_identifier: cainome::cairo_serde::U256,
}
impl cainome::cairo_serde::CairoSerde for EventEnded {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += cainome::cairo_serde::U256::cairo_serialized_size(
                &__rust.event_identifier,
            );
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out
            .extend(
                cainome::cairo_serde::U256::cairo_serialize(&__rust.event_identifier),
            );
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let event_identifier = cainome::cairo_serde::U256::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::U256::cairo_serialized_size(&event_identifier);
        Ok(EventEnded { event_identifier })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct EventStruct {
    pub event_name: cainome::cairo_serde::ByteArray,
    pub time: Time,
    pub active_status: bool,
    pub signature_count: cainome::cairo_serde::U256,
    pub event_organizer: cainome::cairo_serde::ContractAddress,
    pub registered_attendants: cainome::cairo_serde::U256,
    pub event_uri: cainome::cairo_serde::ByteArray,
    pub is_suspended: bool,
    pub event_id: cainome::cairo_serde::U256,
    pub location: u8,
    pub canceled: bool,
}
impl cainome::cairo_serde::CairoSerde for EventStruct {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(
                &__rust.event_name,
            );
        __size += Time::cairo_serialized_size(&__rust.time);
        __size += bool::cairo_serialized_size(&__rust.active_status);
        __size
            += cainome::cairo_serde::U256::cairo_serialized_size(
                &__rust.signature_count,
            );
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.event_organizer,
            );
        __size
            += cainome::cairo_serde::U256::cairo_serialized_size(
                &__rust.registered_attendants,
            );
        __size
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(&__rust.event_uri);
        __size += bool::cairo_serialized_size(&__rust.is_suspended);
        __size += cainome::cairo_serde::U256::cairo_serialized_size(&__rust.event_id);
        __size += u8::cairo_serialized_size(&__rust.location);
        __size += bool::cairo_serialized_size(&__rust.canceled);
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out
            .extend(
                cainome::cairo_serde::ByteArray::cairo_serialize(&__rust.event_name),
            );
        __out.extend(Time::cairo_serialize(&__rust.time));
        __out.extend(bool::cairo_serialize(&__rust.active_status));
        __out
            .extend(
                cainome::cairo_serde::U256::cairo_serialize(&__rust.signature_count),
            );
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    &__rust.event_organizer,
                ),
            );
        __out
            .extend(
                cainome::cairo_serde::U256::cairo_serialize(
                    &__rust.registered_attendants,
                ),
            );
        __out
            .extend(cainome::cairo_serde::ByteArray::cairo_serialize(&__rust.event_uri));
        __out.extend(bool::cairo_serialize(&__rust.is_suspended));
        __out.extend(cainome::cairo_serde::U256::cairo_serialize(&__rust.event_id));
        __out.extend(u8::cairo_serialize(&__rust.location));
        __out.extend(bool::cairo_serialize(&__rust.canceled));
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let event_name = cainome::cairo_serde::ByteArray::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::ByteArray::cairo_serialized_size(&event_name);
        let time = Time::cairo_deserialize(__felts, __offset)?;
        __offset += Time::cairo_serialized_size(&time);
        let active_status = bool::cairo_deserialize(__felts, __offset)?;
        __offset += bool::cairo_serialized_size(&active_status);
        let signature_count = cainome::cairo_serde::U256::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::U256::cairo_serialized_size(&signature_count);
        let event_organizer = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &event_organizer,
            );
        let registered_attendants = cainome::cairo_serde::U256::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::U256::cairo_serialized_size(&registered_attendants);
        let event_uri = cainome::cairo_serde::ByteArray::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::ByteArray::cairo_serialized_size(&event_uri);
        let is_suspended = bool::cairo_deserialize(__felts, __offset)?;
        __offset += bool::cairo_serialized_size(&is_suspended);
        let event_id = cainome::cairo_serde::U256::cairo_deserialize(__felts, __offset)?;
        __offset += cainome::cairo_serde::U256::cairo_serialized_size(&event_id);
        let location = u8::cairo_deserialize(__felts, __offset)?;
        __offset += u8::cairo_serialized_size(&location);
        let canceled = bool::cairo_deserialize(__felts, __offset)?;
        __offset += bool::cairo_serialized_size(&canceled);
        Ok(EventStruct {
            event_name,
            time,
            active_status,
            signature_count,
            event_organizer,
            registered_attendants,
            event_uri,
            is_suspended,
            event_id,
            location,
            canceled,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct OwnershipTransferStarted {
    pub previous_owner: cainome::cairo_serde::ContractAddress,
    pub new_owner: cainome::cairo_serde::ContractAddress,
}
impl cainome::cairo_serde::CairoSerde for OwnershipTransferStarted {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.previous_owner,
            );
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.new_owner,
            );
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    &__rust.previous_owner,
                ),
            );
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(&__rust.new_owner),
            );
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let previous_owner = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &previous_owner,
            );
        let new_owner = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&new_owner);
        Ok(OwnershipTransferStarted {
            previous_owner,
            new_owner,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct OwnershipTransferred {
    pub previous_owner: cainome::cairo_serde::ContractAddress,
    pub new_owner: cainome::cairo_serde::ContractAddress,
}
impl cainome::cairo_serde::CairoSerde for OwnershipTransferred {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.previous_owner,
            );
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.new_owner,
            );
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    &__rust.previous_owner,
                ),
            );
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(&__rust.new_owner),
            );
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let previous_owner = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &previous_owner,
            );
        let new_owner = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&new_owner);
        Ok(OwnershipTransferred {
            previous_owner,
            new_owner,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct RegisteredForEvent {
    pub event_identifier: cainome::cairo_serde::U256,
    pub attendee: cainome::cairo_serde::ContractAddress,
}
impl cainome::cairo_serde::CairoSerde for RegisteredForEvent {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += cainome::cairo_serde::U256::cairo_serialized_size(
                &__rust.event_identifier,
            );
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.attendee,
            );
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out
            .extend(
                cainome::cairo_serde::U256::cairo_serialize(&__rust.event_identifier),
            );
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(&__rust.attendee),
            );
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let event_identifier = cainome::cairo_serde::U256::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::U256::cairo_serialized_size(&event_identifier);
        let attendee = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&attendee);
        Ok(RegisteredForEvent {
            event_identifier,
            attendee,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct RegistrationStatusChanged {
    pub event_identifier: cainome::cairo_serde::U256,
    pub registration_open: u8,
}
impl cainome::cairo_serde::CairoSerde for RegistrationStatusChanged {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += cainome::cairo_serde::U256::cairo_serialized_size(
                &__rust.event_identifier,
            );
        __size += u8::cairo_serialized_size(&__rust.registration_open);
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out
            .extend(
                cainome::cairo_serde::U256::cairo_serialize(&__rust.event_identifier),
            );
        __out.extend(u8::cairo_serialize(&__rust.registration_open));
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let event_identifier = cainome::cairo_serde::U256::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::U256::cairo_serialized_size(&event_identifier);
        let registration_open = u8::cairo_deserialize(__felts, __offset)?;
        __offset += u8::cairo_serialized_size(&registration_open);
        Ok(RegistrationStatusChanged {
            event_identifier,
            registration_open,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct Sponsor {
    pub amt: cainome::cairo_serde::U256,
    pub uri: cainome::cairo_serde::ByteArray,
    pub event: cainome::cairo_serde::ContractAddress,
}
impl cainome::cairo_serde::CairoSerde for Sponsor {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size += cainome::cairo_serde::U256::cairo_serialized_size(&__rust.amt);
        __size += cainome::cairo_serde::ByteArray::cairo_serialized_size(&__rust.uri);
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.event,
            );
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out.extend(cainome::cairo_serde::U256::cairo_serialize(&__rust.amt));
        __out.extend(cainome::cairo_serde::ByteArray::cairo_serialize(&__rust.uri));
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(&__rust.event),
            );
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let amt = cainome::cairo_serde::U256::cairo_deserialize(__felts, __offset)?;
        __offset += cainome::cairo_serde::U256::cairo_serialized_size(&amt);
        let uri = cainome::cairo_serde::ByteArray::cairo_deserialize(__felts, __offset)?;
        __offset += cainome::cairo_serde::ByteArray::cairo_serialized_size(&uri);
        let event = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&event);
        Ok(Sponsor { amt, uri, event })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct Time {
    pub registration_open: u8,
    pub start_time: cainome::cairo_serde::U256,
    pub end_time: cainome::cairo_serde::U256,
}
impl cainome::cairo_serde::CairoSerde for Time {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size += u8::cairo_serialized_size(&__rust.registration_open);
        __size += cainome::cairo_serde::U256::cairo_serialized_size(&__rust.start_time);
        __size += cainome::cairo_serde::U256::cairo_serialized_size(&__rust.end_time);
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out.extend(u8::cairo_serialize(&__rust.registration_open));
        __out.extend(cainome::cairo_serde::U256::cairo_serialize(&__rust.start_time));
        __out.extend(cainome::cairo_serde::U256::cairo_serialize(&__rust.end_time));
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let registration_open = u8::cairo_deserialize(__felts, __offset)?;
        __offset += u8::cairo_serialized_size(&registration_open);
        let start_time = cainome::cairo_serde::U256::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::U256::cairo_serialized_size(&start_time);
        let end_time = cainome::cairo_serde::U256::cairo_deserialize(__felts, __offset)?;
        __offset += cainome::cairo_serde::U256::cairo_serialized_size(&end_time);
        Ok(Time {
            registration_open,
            start_time,
            end_time,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct Upgraded {
    pub class_hash: cainome::cairo_serde::ClassHash,
}
impl cainome::cairo_serde::CairoSerde for Upgraded {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += cainome::cairo_serde::ClassHash::cairo_serialized_size(
                &__rust.class_hash,
            );
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out
            .extend(
                cainome::cairo_serde::ClassHash::cairo_serialize(&__rust.class_hash),
            );
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let class_hash = cainome::cairo_serde::ClassHash::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::ClassHash::cairo_serialized_size(&class_hash);
        Ok(Upgraded { class_hash })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct UserAttendedEventStruct {
    pub event_name: cainome::cairo_serde::ByteArray,
    pub time: Time,
    pub event_organizer: cainome::cairo_serde::ContractAddress,
    pub event_id: cainome::cairo_serde::U256,
    pub event_uri: cainome::cairo_serde::ByteArray,
}
impl cainome::cairo_serde::CairoSerde for UserAttendedEventStruct {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(
                &__rust.event_name,
            );
        __size += Time::cairo_serialized_size(&__rust.time);
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.event_organizer,
            );
        __size += cainome::cairo_serde::U256::cairo_serialized_size(&__rust.event_id);
        __size
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(&__rust.event_uri);
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out
            .extend(
                cainome::cairo_serde::ByteArray::cairo_serialize(&__rust.event_name),
            );
        __out.extend(Time::cairo_serialize(&__rust.time));
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    &__rust.event_organizer,
                ),
            );
        __out.extend(cainome::cairo_serde::U256::cairo_serialize(&__rust.event_id));
        __out
            .extend(cainome::cairo_serde::ByteArray::cairo_serialize(&__rust.event_uri));
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let event_name = cainome::cairo_serde::ByteArray::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::ByteArray::cairo_serialized_size(&event_name);
        let time = Time::cairo_deserialize(__felts, __offset)?;
        __offset += Time::cairo_serialized_size(&time);
        let event_organizer = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &event_organizer,
            );
        let event_id = cainome::cairo_serde::U256::cairo_deserialize(__felts, __offset)?;
        __offset += cainome::cairo_serde::U256::cairo_serialized_size(&event_id);
        let event_uri = cainome::cairo_serde::ByteArray::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::ByteArray::cairo_serialized_size(&event_uri);
        Ok(UserAttendedEventStruct {
            event_name,
            time,
            event_organizer,
            event_id,
            event_uri,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct Withdrawn {
    pub amt: cainome::cairo_serde::U256,
    pub event: cainome::cairo_serde::ContractAddress,
}
impl cainome::cairo_serde::CairoSerde for Withdrawn {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size += cainome::cairo_serde::U256::cairo_serialized_size(&__rust.amt);
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.event,
            );
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out.extend(cainome::cairo_serde::U256::cairo_serialize(&__rust.amt));
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(&__rust.event),
            );
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let amt = cainome::cairo_serde::U256::cairo_deserialize(__felts, __offset)?;
        __offset += cainome::cairo_serde::U256::cairo_serialized_size(&amt);
        let event = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&event);
        Ok(Withdrawn { amt, event })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub enum Event {
    Sponsor(Sponsor),
    Withdrawn(Withdrawn),
    EventCreated(EventCreated),
    EventEnded(EventEnded),
    AttendanceMarked(AttendanceMarked),
    RegisteredForEvent(RegisteredForEvent),
    RegistrationStatusChanged(RegistrationStatusChanged),
    AdminTransferred(AdminTransferred),
    AdminOwnershipClaimed(AdminOwnershipClaimed),
    BatchCertificationCompleted(BatchCertificationCompleted),
    OwnableEvent(OwnableComponentEvent),
    UpgradeableEvent(UpgradeableComponentEvent),
}
impl cainome::cairo_serde::CairoSerde for Event {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = std::option::Option::None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        match __rust {
            Event::Sponsor(val) => Sponsor::cairo_serialized_size(val) + 1,
            Event::Withdrawn(val) => Withdrawn::cairo_serialized_size(val) + 1,
            Event::EventCreated(val) => EventCreated::cairo_serialized_size(val) + 1,
            Event::EventEnded(val) => EventEnded::cairo_serialized_size(val) + 1,
            Event::AttendanceMarked(val) => {
                AttendanceMarked::cairo_serialized_size(val) + 1
            }
            Event::RegisteredForEvent(val) => {
                RegisteredForEvent::cairo_serialized_size(val) + 1
            }
            Event::RegistrationStatusChanged(val) => {
                RegistrationStatusChanged::cairo_serialized_size(val) + 1
            }
            Event::AdminTransferred(val) => {
                AdminTransferred::cairo_serialized_size(val) + 1
            }
            Event::AdminOwnershipClaimed(val) => {
                AdminOwnershipClaimed::cairo_serialized_size(val) + 1
            }
            Event::BatchCertificationCompleted(val) => {
                BatchCertificationCompleted::cairo_serialized_size(val) + 1
            }
            Event::OwnableEvent(val) => {
                OwnableComponentEvent::cairo_serialized_size(val) + 1
            }
            Event::UpgradeableEvent(val) => {
                UpgradeableComponentEvent::cairo_serialized_size(val) + 1
            }
            _ => 0,
        }
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        match __rust {
            Event::Sponsor(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&0usize));
                temp.extend(Sponsor::cairo_serialize(val));
                temp
            }
            Event::Withdrawn(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&1usize));
                temp.extend(Withdrawn::cairo_serialize(val));
                temp
            }
            Event::EventCreated(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&2usize));
                temp.extend(EventCreated::cairo_serialize(val));
                temp
            }
            Event::EventEnded(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&3usize));
                temp.extend(EventEnded::cairo_serialize(val));
                temp
            }
            Event::AttendanceMarked(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&4usize));
                temp.extend(AttendanceMarked::cairo_serialize(val));
                temp
            }
            Event::RegisteredForEvent(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&5usize));
                temp.extend(RegisteredForEvent::cairo_serialize(val));
                temp
            }
            Event::RegistrationStatusChanged(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&6usize));
                temp.extend(RegistrationStatusChanged::cairo_serialize(val));
                temp
            }
            Event::AdminTransferred(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&7usize));
                temp.extend(AdminTransferred::cairo_serialize(val));
                temp
            }
            Event::AdminOwnershipClaimed(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&8usize));
                temp.extend(AdminOwnershipClaimed::cairo_serialize(val));
                temp
            }
            Event::BatchCertificationCompleted(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&9usize));
                temp.extend(BatchCertificationCompleted::cairo_serialize(val));
                temp
            }
            Event::OwnableEvent(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&10usize));
                temp.extend(OwnableComponentEvent::cairo_serialize(val));
                temp
            }
            Event::UpgradeableEvent(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&11usize));
                temp.extend(UpgradeableComponentEvent::cairo_serialize(val));
                temp
            }
            _ => vec![],
        }
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let __f = __felts[__offset];
        let __index = u128::from_be_bytes(__f.to_bytes_be()[16..].try_into().unwrap());
        match __index as usize {
            0usize => {
                Ok(Event::Sponsor(Sponsor::cairo_deserialize(__felts, __offset + 1)?))
            }
            1usize => {
                Ok(
                    Event::Withdrawn(
                        Withdrawn::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            2usize => {
                Ok(
                    Event::EventCreated(
                        EventCreated::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            3usize => {
                Ok(
                    Event::EventEnded(
                        EventEnded::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            4usize => {
                Ok(
                    Event::AttendanceMarked(
                        AttendanceMarked::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            5usize => {
                Ok(
                    Event::RegisteredForEvent(
                        RegisteredForEvent::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            6usize => {
                Ok(
                    Event::RegistrationStatusChanged(
                        RegistrationStatusChanged::cairo_deserialize(
                            __felts,
                            __offset + 1,
                        )?,
                    ),
                )
            }
            7usize => {
                Ok(
                    Event::AdminTransferred(
                        AdminTransferred::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            8usize => {
                Ok(
                    Event::AdminOwnershipClaimed(
                        AdminOwnershipClaimed::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            9usize => {
                Ok(
                    Event::BatchCertificationCompleted(
                        BatchCertificationCompleted::cairo_deserialize(
                            __felts,
                            __offset + 1,
                        )?,
                    ),
                )
            }
            10usize => {
                Ok(
                    Event::OwnableEvent(
                        OwnableComponentEvent::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            11usize => {
                Ok(
                    Event::UpgradeableEvent(
                        UpgradeableComponentEvent::cairo_deserialize(
                            __felts,
                            __offset + 1,
                        )?,
                    ),
                )
            }
            _ => {
                return Err(
                    cainome::cairo_serde::Error::Deserialize(
                        format!("Index not handle for enum {}", "Event"),
                    ),
                );
            }
        }
    }
}
impl TryFrom<starknet::core::types::EmittedEvent> for Event {
    type Error = String;
    fn try_from(
        event: starknet::core::types::EmittedEvent,
    ) -> Result<Self, Self::Error> {
        use cainome::cairo_serde::CairoSerde;
        if event.keys.is_empty() {
            return Err("Event has no key".to_string());
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("Sponsor")
                .unwrap_or_else(|_| panic!("Invalid selector for {}", "Sponsor"))
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let amt = match cainome::cairo_serde::U256::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "amt",
                            "Sponsor", e
                        ),
                    );
                }
            };
            data_offset += cainome::cairo_serde::U256::cairo_serialized_size(&amt);
            let uri = match cainome::cairo_serde::ByteArray::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "uri",
                            "Sponsor", e
                        ),
                    );
                }
            };
            data_offset += cainome::cairo_serde::ByteArray::cairo_serialized_size(&uri);
            let event = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "event",
                            "Sponsor", e
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&event);
            return Ok(Event::Sponsor(Sponsor { amt, uri, event }));
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("Withdrawn")
                .unwrap_or_else(|_| panic!("Invalid selector for {}", "Withdrawn"))
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let amt = match cainome::cairo_serde::U256::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "amt",
                            "Withdrawn", e
                        ),
                    );
                }
            };
            data_offset += cainome::cairo_serde::U256::cairo_serialized_size(&amt);
            let event = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "event",
                            "Withdrawn", e
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&event);
            return Ok(Event::Withdrawn(Withdrawn { amt, event }));
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("EventCreated")
                .unwrap_or_else(|_| panic!("Invalid selector for {}", "EventCreated"))
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let event_identifier = match cainome::cairo_serde::U256::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "event_identifier", "EventCreated", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::U256::cairo_serialized_size(&event_identifier);
            let event_name = match cainome::cairo_serde::ByteArray::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "event_name",
                            "EventCreated", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ByteArray::cairo_serialized_size(&event_name);
            let event_organizer = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "event_organizer", "EventCreated", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &event_organizer,
                );
            let event_uri = match cainome::cairo_serde::ByteArray::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "event_uri",
                            "EventCreated", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ByteArray::cairo_serialized_size(&event_uri);
            return Ok(
                Event::EventCreated(EventCreated {
                    event_identifier,
                    event_name,
                    event_organizer,
                    event_uri,
                }),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("EventEnded")
                .unwrap_or_else(|_| panic!("Invalid selector for {}", "EventEnded"))
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let event_identifier = match cainome::cairo_serde::U256::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "event_identifier", "EventEnded", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::U256::cairo_serialized_size(&event_identifier);
            return Ok(Event::EventEnded(EventEnded { event_identifier }));
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("AttendanceMarked")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "AttendanceMarked")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let event_identifier = match cainome::cairo_serde::U256::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "event_identifier", "AttendanceMarked", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::U256::cairo_serialized_size(&event_identifier);
            let attendee = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "attendee",
                            "AttendanceMarked", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &attendee,
                );
            return Ok(
                Event::AttendanceMarked(AttendanceMarked {
                    event_identifier,
                    attendee,
                }),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("RegisteredForEvent")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "RegisteredForEvent")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let event_identifier = match cainome::cairo_serde::U256::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "event_identifier", "RegisteredForEvent", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::U256::cairo_serialized_size(&event_identifier);
            let attendee = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "attendee",
                            "RegisteredForEvent", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &attendee,
                );
            return Ok(
                Event::RegisteredForEvent(RegisteredForEvent {
                    event_identifier,
                    attendee,
                }),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("RegistrationStatusChanged")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "RegistrationStatusChanged")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let event_identifier = match cainome::cairo_serde::U256::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "event_identifier", "RegistrationStatusChanged", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::U256::cairo_serialized_size(&event_identifier);
            let registration_open = match u8::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "registration_open", "RegistrationStatusChanged", e
                        ),
                    );
                }
            };
            data_offset += u8::cairo_serialized_size(&registration_open);
            return Ok(
                Event::RegistrationStatusChanged(RegistrationStatusChanged {
                    event_identifier,
                    registration_open,
                }),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("AdminTransferred")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "AdminTransferred")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let old_admin = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "old_admin",
                            "AdminTransferred", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &old_admin,
                );
            let new_admin = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "new_admin",
                            "AdminTransferred", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &new_admin,
                );
            return Ok(
                Event::AdminTransferred(AdminTransferred {
                    old_admin,
                    new_admin,
                }),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("AdminOwnershipClaimed")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "AdminOwnershipClaimed")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let new_admin = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "new_admin",
                            "AdminOwnershipClaimed", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &new_admin,
                );
            return Ok(Event::AdminOwnershipClaimed(AdminOwnershipClaimed { new_admin }));
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name(
                    "BatchCertificationCompleted",
                )
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "BatchCertificationCompleted")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let event_identifier = match cainome::cairo_serde::U256::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "event_identifier", "BatchCertificationCompleted", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::U256::cairo_serialized_size(&event_identifier);
            let certified_attendees = match Vec::<
                cainome::cairo_serde::ContractAddress,
            >::cairo_deserialize(&event.data, data_offset) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "certified_attendees", "BatchCertificationCompleted", e
                        ),
                    );
                }
            };
            data_offset
                += Vec::<
                    cainome::cairo_serde::ContractAddress,
                >::cairo_serialized_size(&certified_attendees);
            return Ok(
                Event::BatchCertificationCompleted(BatchCertificationCompleted {
                    event_identifier,
                    certified_attendees,
                }),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("OwnershipTransferred")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "OwnershipTransferred")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let previous_owner = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "previous_owner", "OwnershipTransferred", e
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &previous_owner,
                );
            let new_owner = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "new_owner",
                            "OwnershipTransferred", e
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &new_owner,
                );
            return Ok(
                Event::OwnableEvent(
                    OwnableComponentEvent::OwnershipTransferred(OwnershipTransferred {
                        previous_owner,
                        new_owner,
                    }),
                ),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("OwnershipTransferStarted")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "OwnershipTransferStarted")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let previous_owner = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "previous_owner", "OwnershipTransferStarted", e
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &previous_owner,
                );
            let new_owner = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "new_owner",
                            "OwnershipTransferStarted", e
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &new_owner,
                );
            return Ok(
                Event::OwnableEvent(
                    OwnableComponentEvent::OwnershipTransferStarted(OwnershipTransferStarted {
                        previous_owner,
                        new_owner,
                    }),
                ),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("Upgraded")
                .unwrap_or_else(|_| panic!("Invalid selector for {}", "Upgraded"))
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let class_hash = match cainome::cairo_serde::ClassHash::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "class_hash",
                            "Upgraded", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ClassHash::cairo_serialized_size(&class_hash);
            return Ok(
                Event::UpgradeableEvent(
                    UpgradeableComponentEvent::Upgraded(Upgraded { class_hash }),
                ),
            );
        }
        Err(format!("Could not match any event from keys {:?}", event.keys))
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub enum OwnableComponentEvent {
    OwnershipTransferred(OwnershipTransferred),
    OwnershipTransferStarted(OwnershipTransferStarted),
}
impl cainome::cairo_serde::CairoSerde for OwnableComponentEvent {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = std::option::Option::None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        match __rust {
            OwnableComponentEvent::OwnershipTransferred(val) => {
                OwnershipTransferred::cairo_serialized_size(val) + 1
            }
            OwnableComponentEvent::OwnershipTransferStarted(val) => {
                OwnershipTransferStarted::cairo_serialized_size(val) + 1
            }
            _ => 0,
        }
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        match __rust {
            OwnableComponentEvent::OwnershipTransferred(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&0usize));
                temp.extend(OwnershipTransferred::cairo_serialize(val));
                temp
            }
            OwnableComponentEvent::OwnershipTransferStarted(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&1usize));
                temp.extend(OwnershipTransferStarted::cairo_serialize(val));
                temp
            }
            _ => vec![],
        }
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let __f = __felts[__offset];
        let __index = u128::from_be_bytes(__f.to_bytes_be()[16..].try_into().unwrap());
        match __index as usize {
            0usize => {
                Ok(
                    OwnableComponentEvent::OwnershipTransferred(
                        OwnershipTransferred::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            1usize => {
                Ok(
                    OwnableComponentEvent::OwnershipTransferStarted(
                        OwnershipTransferStarted::cairo_deserialize(
                            __felts,
                            __offset + 1,
                        )?,
                    ),
                )
            }
            _ => {
                return Err(
                    cainome::cairo_serde::Error::Deserialize(
                        format!("Index not handle for enum {}", "OwnableComponentEvent"),
                    ),
                );
            }
        }
    }
}
impl TryFrom<starknet::core::types::EmittedEvent> for OwnableComponentEvent {
    type Error = String;
    fn try_from(
        event: starknet::core::types::EmittedEvent,
    ) -> Result<Self, Self::Error> {
        use cainome::cairo_serde::CairoSerde;
        if event.keys.is_empty() {
            return Err("Event has no key".to_string());
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("OwnershipTransferred")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "OwnershipTransferred")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let previous_owner = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "previous_owner", "OwnershipTransferred", e
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &previous_owner,
                );
            let new_owner = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "new_owner",
                            "OwnershipTransferred", e
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &new_owner,
                );
            return Ok(
                OwnableComponentEvent::OwnershipTransferred(OwnershipTransferred {
                    previous_owner,
                    new_owner,
                }),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("OwnershipTransferStarted")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "OwnershipTransferStarted")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let previous_owner = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "previous_owner", "OwnershipTransferStarted", e
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &previous_owner,
                );
            let new_owner = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "new_owner",
                            "OwnershipTransferStarted", e
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &new_owner,
                );
            return Ok(
                OwnableComponentEvent::OwnershipTransferStarted(OwnershipTransferStarted {
                    previous_owner,
                    new_owner,
                }),
            );
        }
        Err(format!("Could not match any event from keys {:?}", event.keys))
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub enum UpgradeableComponentEvent {
    Upgraded(Upgraded),
}
impl cainome::cairo_serde::CairoSerde for UpgradeableComponentEvent {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = std::option::Option::None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        match __rust {
            UpgradeableComponentEvent::Upgraded(val) => {
                Upgraded::cairo_serialized_size(val) + 1
            }
            _ => 0,
        }
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        match __rust {
            UpgradeableComponentEvent::Upgraded(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&0usize));
                temp.extend(Upgraded::cairo_serialize(val));
                temp
            }
            _ => vec![],
        }
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let __f = __felts[__offset];
        let __index = u128::from_be_bytes(__f.to_bytes_be()[16..].try_into().unwrap());
        match __index as usize {
            0usize => {
                Ok(
                    UpgradeableComponentEvent::Upgraded(
                        Upgraded::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            _ => {
                return Err(
                    cainome::cairo_serde::Error::Deserialize(
                        format!(
                            "Index not handle for enum {}", "UpgradeableComponentEvent"
                        ),
                    ),
                );
            }
        }
    }
}
impl TryFrom<starknet::core::types::EmittedEvent> for UpgradeableComponentEvent {
    type Error = String;
    fn try_from(
        event: starknet::core::types::EmittedEvent,
    ) -> Result<Self, Self::Error> {
        use cainome::cairo_serde::CairoSerde;
        if event.keys.is_empty() {
            return Err("Event has no key".to_string());
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("Upgraded")
                .unwrap_or_else(|_| panic!("Invalid selector for {}", "Upgraded"))
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let class_hash = match cainome::cairo_serde::ClassHash::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "class_hash",
                            "Upgraded", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ClassHash::cairo_serialized_size(&class_hash);
            return Ok(UpgradeableComponentEvent::Upgraded(Upgraded { class_hash }));
        }
        Err(format!("Could not match any event from keys {:?}", event.keys))
    }
}
impl<A: starknet::accounts::ConnectedAccount + Sync> eventsubgraph<A> {
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_admin(
        &self,
    ) -> cainome::cairo_serde::call::FCall<
        A::Provider,
        cainome::cairo_serde::ContractAddress,
    > {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_admin"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_all_attendace_marked(
        &self,
        event_identifier: &cainome::cairo_serde::U256,
    ) -> cainome::cairo_serde::call::FCall<
        A::Provider,
        Vec<cainome::cairo_serde::ContractAddress>,
    > {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(event_identifier));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!(
                "get_all_attendace_marked"
            ),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_all_attended_events(
        &self,
        user: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<A::Provider, Vec<UserAttendedEventStruct>> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(user));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_all_attended_events"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_all_created_events(
        &self,
        organizer: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<A::Provider, Vec<EventStruct>> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(organizer));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_all_created_events"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_all_events(
        &self,
    ) -> cainome::cairo_serde::call::FCall<A::Provider, Vec<EventStruct>> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_all_events"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_all_list_registered_events(
        &self,
        user: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<A::Provider, Vec<UserAttendedEventStruct>> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(user));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!(
                "get_all_list_registered_events"
            ),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_attendance_status(
        &self,
        attendee: &cainome::cairo_serde::ContractAddress,
        event_identifier: &cainome::cairo_serde::U256,
    ) -> cainome::cairo_serde::call::FCall<A::Provider, bool> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(attendee));
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(event_identifier));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_attendance_status"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_cancelation_status(
        &self,
        event_identifier: &cainome::cairo_serde::U256,
    ) -> cainome::cairo_serde::call::FCall<A::Provider, bool> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(event_identifier));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_cancelation_status"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_event_details(
        &self,
        event_identifier: &cainome::cairo_serde::U256,
    ) -> cainome::cairo_serde::call::FCall<A::Provider, EventStruct> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(event_identifier));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_event_details"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_event_nft_contract(
        &self,
        event_identifier: &cainome::cairo_serde::U256,
    ) -> cainome::cairo_serde::call::FCall<
        A::Provider,
        cainome::cairo_serde::ContractAddress,
    > {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(event_identifier));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_event_nft_contract"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_event_sponsorship_balance(
        &self,
        event: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<A::Provider, cainome::cairo_serde::U256> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(event));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!(
                "get_event_sponsorship_balance"
            ),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_event_suspended_status(
        &self,
        event_identifier: &cainome::cairo_serde::U256,
    ) -> cainome::cairo_serde::call::FCall<A::Provider, bool> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(event_identifier));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!(
                "get_event_suspended_status"
            ),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_if_registration_is_open(
        &self,
        event_identifier: &cainome::cairo_serde::U256,
    ) -> cainome::cairo_serde::call::FCall<A::Provider, u8> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(event_identifier));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!(
                "get_if_registration_is_open"
            ),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_new_admin(
        &self,
    ) -> cainome::cairo_serde::call::FCall<
        A::Provider,
        cainome::cairo_serde::ContractAddress,
    > {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_new_admin"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_registered_users(
        &self,
        event_identifier: &cainome::cairo_serde::U256,
    ) -> cainome::cairo_serde::call::FCall<A::Provider, Vec<AttendeeInfo>> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(event_identifier));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_registered_users"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn owner(
        &self,
    ) -> cainome::cairo_serde::call::FCall<
        A::Provider,
        cainome::cairo_serde::ContractAddress,
    > {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("owner"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn batch_certify_attendees_getcall(
        &self,
        event_identifier: &cainome::cairo_serde::U256,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(event_identifier));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("batch_certify_attendees"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn batch_certify_attendees(
        &self,
        event_identifier: &cainome::cairo_serde::U256,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(event_identifier));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("batch_certify_attendees"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn cancel_event_getcall(
        &self,
        event_identifier: &cainome::cairo_serde::U256,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(event_identifier));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("cancel_event"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn cancel_event(
        &self,
        event_identifier: &cainome::cairo_serde::U256,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(event_identifier));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("cancel_event"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn claim_admin_ownership_getcall(&self) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("claim_admin_ownership"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn claim_admin_ownership(&self) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("claim_admin_ownership"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn create_event_getcall(
        &self,
        owner_: &cainome::cairo_serde::ContractAddress,
        event_name: &cainome::cairo_serde::ByteArray,
        base_uri: &cainome::cairo_serde::ByteArray,
        name_: &cainome::cairo_serde::ByteArray,
        symbol: &cainome::cairo_serde::ByteArray,
        start_time_: &cainome::cairo_serde::U256,
        end_time_: &cainome::cairo_serde::U256,
        reg_status: &u8,
        event_uri: &cainome::cairo_serde::ByteArray,
        event_location: &u8,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(owner_));
        __calldata.extend(cainome::cairo_serde::ByteArray::cairo_serialize(event_name));
        __calldata.extend(cainome::cairo_serde::ByteArray::cairo_serialize(base_uri));
        __calldata.extend(cainome::cairo_serde::ByteArray::cairo_serialize(name_));
        __calldata.extend(cainome::cairo_serde::ByteArray::cairo_serialize(symbol));
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(start_time_));
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(end_time_));
        __calldata.extend(u8::cairo_serialize(reg_status));
        __calldata.extend(cainome::cairo_serde::ByteArray::cairo_serialize(event_uri));
        __calldata.extend(u8::cairo_serialize(event_location));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("create_event"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn create_event(
        &self,
        owner_: &cainome::cairo_serde::ContractAddress,
        event_name: &cainome::cairo_serde::ByteArray,
        base_uri: &cainome::cairo_serde::ByteArray,
        name_: &cainome::cairo_serde::ByteArray,
        symbol: &cainome::cairo_serde::ByteArray,
        start_time_: &cainome::cairo_serde::U256,
        end_time_: &cainome::cairo_serde::U256,
        reg_status: &u8,
        event_uri: &cainome::cairo_serde::ByteArray,
        event_location: &u8,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(owner_));
        __calldata.extend(cainome::cairo_serde::ByteArray::cairo_serialize(event_name));
        __calldata.extend(cainome::cairo_serde::ByteArray::cairo_serialize(base_uri));
        __calldata.extend(cainome::cairo_serde::ByteArray::cairo_serialize(name_));
        __calldata.extend(cainome::cairo_serde::ByteArray::cairo_serialize(symbol));
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(start_time_));
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(end_time_));
        __calldata.extend(u8::cairo_serialize(reg_status));
        __calldata.extend(cainome::cairo_serde::ByteArray::cairo_serialize(event_uri));
        __calldata.extend(u8::cairo_serialize(event_location));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("create_event"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn end_event_getcall(
        &self,
        event_identifier: &cainome::cairo_serde::U256,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(event_identifier));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("end_event"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn end_event(
        &self,
        event_identifier: &cainome::cairo_serde::U256,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(event_identifier));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("end_event"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn mark_attendance_getcall(
        &self,
        event_identifier: &cainome::cairo_serde::U256,
        attendee_: &cainome::cairo_serde::ContractAddress,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(event_identifier));
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(attendee_));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("mark_attendance"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn mark_attendance(
        &self,
        event_identifier: &cainome::cairo_serde::U256,
        attendee_: &cainome::cairo_serde::ContractAddress,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(event_identifier));
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(attendee_));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("mark_attendance"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn register_for_event_getcall(
        &self,
        event_identifier: &cainome::cairo_serde::U256,
        user_uri: &cainome::cairo_serde::ByteArray,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(event_identifier));
        __calldata.extend(cainome::cairo_serde::ByteArray::cairo_serialize(user_uri));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("register_for_event"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn register_for_event(
        &self,
        event_identifier: &cainome::cairo_serde::U256,
        user_uri: &cainome::cairo_serde::ByteArray,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(event_identifier));
        __calldata.extend(cainome::cairo_serde::ByteArray::cairo_serialize(user_uri));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("register_for_event"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn renounce_ownership_getcall(&self) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("renounce_ownership"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn renounce_ownership(&self) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("renounce_ownership"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn set_sponsorship_contract_getcall(
        &self,
        sponsor_contract_address: &cainome::cairo_serde::ContractAddress,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    sponsor_contract_address,
                ),
            );
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("set_sponsorship_contract"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn set_sponsorship_contract(
        &self,
        sponsor_contract_address: &cainome::cairo_serde::ContractAddress,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    sponsor_contract_address,
                ),
            );
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("set_sponsorship_contract"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn sponsor_event_getcall(
        &self,
        event_identifier: &cainome::cairo_serde::U256,
        amt: &cainome::cairo_serde::U256,
        uri: &cainome::cairo_serde::ByteArray,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(event_identifier));
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(amt));
        __calldata.extend(cainome::cairo_serde::ByteArray::cairo_serialize(uri));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("sponsor_event"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn sponsor_event(
        &self,
        event_identifier: &cainome::cairo_serde::U256,
        amt: &cainome::cairo_serde::U256,
        uri: &cainome::cairo_serde::ByteArray,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(event_identifier));
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(amt));
        __calldata.extend(cainome::cairo_serde::ByteArray::cairo_serialize(uri));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("sponsor_event"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn start_end_reg_getcall(
        &self,
        reg_stat: &u8,
        event_identifier: &cainome::cairo_serde::U256,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(u8::cairo_serialize(reg_stat));
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(event_identifier));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("start_end_reg"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn start_end_reg(
        &self,
        reg_stat: &u8,
        event_identifier: &cainome::cairo_serde::U256,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(u8::cairo_serialize(reg_stat));
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(event_identifier));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("start_end_reg"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn toggle_event_suspended_status_getcall(
        &self,
        event_identifier: &cainome::cairo_serde::U256,
        status: &bool,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(event_identifier));
        __calldata.extend(bool::cairo_serialize(status));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("toggle_event_suspended_status"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn toggle_event_suspended_status(
        &self,
        event_identifier: &cainome::cairo_serde::U256,
        status: &bool,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(event_identifier));
        __calldata.extend(bool::cairo_serialize(status));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("toggle_event_suspended_status"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn transfer_admin_getcall(
        &self,
        new_admin: &cainome::cairo_serde::ContractAddress,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(new_admin));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("transfer_admin"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn transfer_admin(
        &self,
        new_admin: &cainome::cairo_serde::ContractAddress,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(new_admin));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("transfer_admin"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn transfer_ownership_getcall(
        &self,
        new_owner: &cainome::cairo_serde::ContractAddress,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(new_owner));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("transfer_ownership"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn transfer_ownership(
        &self,
        new_owner: &cainome::cairo_serde::ContractAddress,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(new_owner));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("transfer_ownership"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn upgrade_getcall(
        &self,
        new_class_hash: &cainome::cairo_serde::ClassHash,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::ClassHash::cairo_serialize(new_class_hash));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("upgrade"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn upgrade(
        &self,
        new_class_hash: &cainome::cairo_serde::ClassHash,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::ClassHash::cairo_serialize(new_class_hash));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("upgrade"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn withdraw_sponsorship_funds_getcall(
        &self,
        amt: &cainome::cairo_serde::U256,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(amt));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("withdraw_sponsorship_funds"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn withdraw_sponsorship_funds(
        &self,
        amt: &cainome::cairo_serde::U256,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(amt));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("withdraw_sponsorship_funds"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
}
impl<P: starknet::providers::Provider + Sync> eventsubgraphReader<P> {
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_admin(
        &self,
    ) -> cainome::cairo_serde::call::FCall<P, cainome::cairo_serde::ContractAddress> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_admin"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_all_attendace_marked(
        &self,
        event_identifier: &cainome::cairo_serde::U256,
    ) -> cainome::cairo_serde::call::FCall<
        P,
        Vec<cainome::cairo_serde::ContractAddress>,
    > {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(event_identifier));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!(
                "get_all_attendace_marked"
            ),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_all_attended_events(
        &self,
        user: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<P, Vec<UserAttendedEventStruct>> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(user));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_all_attended_events"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_all_created_events(
        &self,
        organizer: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<P, Vec<EventStruct>> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(organizer));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_all_created_events"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_all_events(
        &self,
    ) -> cainome::cairo_serde::call::FCall<P, Vec<EventStruct>> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_all_events"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_all_list_registered_events(
        &self,
        user: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<P, Vec<UserAttendedEventStruct>> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(user));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!(
                "get_all_list_registered_events"
            ),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_attendance_status(
        &self,
        attendee: &cainome::cairo_serde::ContractAddress,
        event_identifier: &cainome::cairo_serde::U256,
    ) -> cainome::cairo_serde::call::FCall<P, bool> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(attendee));
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(event_identifier));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_attendance_status"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_cancelation_status(
        &self,
        event_identifier: &cainome::cairo_serde::U256,
    ) -> cainome::cairo_serde::call::FCall<P, bool> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(event_identifier));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_cancelation_status"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_event_details(
        &self,
        event_identifier: &cainome::cairo_serde::U256,
    ) -> cainome::cairo_serde::call::FCall<P, EventStruct> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(event_identifier));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_event_details"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_event_nft_contract(
        &self,
        event_identifier: &cainome::cairo_serde::U256,
    ) -> cainome::cairo_serde::call::FCall<P, cainome::cairo_serde::ContractAddress> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(event_identifier));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_event_nft_contract"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_event_sponsorship_balance(
        &self,
        event: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<P, cainome::cairo_serde::U256> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(event));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!(
                "get_event_sponsorship_balance"
            ),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_event_suspended_status(
        &self,
        event_identifier: &cainome::cairo_serde::U256,
    ) -> cainome::cairo_serde::call::FCall<P, bool> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(event_identifier));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!(
                "get_event_suspended_status"
            ),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_if_registration_is_open(
        &self,
        event_identifier: &cainome::cairo_serde::U256,
    ) -> cainome::cairo_serde::call::FCall<P, u8> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(event_identifier));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!(
                "get_if_registration_is_open"
            ),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_new_admin(
        &self,
    ) -> cainome::cairo_serde::call::FCall<P, cainome::cairo_serde::ContractAddress> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_new_admin"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_registered_users(
        &self,
        event_identifier: &cainome::cairo_serde::U256,
    ) -> cainome::cairo_serde::call::FCall<P, Vec<AttendeeInfo>> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(event_identifier));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_registered_users"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn owner(
        &self,
    ) -> cainome::cairo_serde::call::FCall<P, cainome::cairo_serde::ContractAddress> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("owner"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
}
