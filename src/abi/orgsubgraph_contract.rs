// ****
// Auto-generated by cainome do not edit.
// ****

#[derive(Debug)]
pub struct orgsubgraph<A: starknet::accounts::ConnectedAccount + Sync> {
    pub address: starknet::core::types::Felt,
    pub account: A,
    pub block_id: starknet::core::types::BlockId,
}
impl<A: starknet::accounts::ConnectedAccount + Sync> orgsubgraph<A> {
    pub fn new(address: starknet::core::types::Felt, account: A) -> Self {
        Self {
            address,
            account,
            block_id: starknet::core::types::BlockId::Tag(
                starknet::core::types::BlockTag::Pending,
            ),
        }
    }
    pub fn set_contract_address(&mut self, address: starknet::core::types::Felt) {
        self.address = address;
    }
    pub fn provider(&self) -> &A::Provider {
        self.account.provider()
    }
    pub fn set_block(&mut self, block_id: starknet::core::types::BlockId) {
        self.block_id = block_id;
    }
    pub fn with_block(self, block_id: starknet::core::types::BlockId) -> Self {
        Self { block_id, ..self }
    }
}
#[derive(Debug)]
pub struct orgsubgraphReader<P: starknet::providers::Provider + Sync> {
    pub address: starknet::core::types::Felt,
    pub provider: P,
    pub block_id: starknet::core::types::BlockId,
}
impl<P: starknet::providers::Provider + Sync> orgsubgraphReader<P> {
    pub fn new(address: starknet::core::types::Felt, provider: P) -> Self {
        Self {
            address,
            provider,
            block_id: starknet::core::types::BlockId::Tag(
                starknet::core::types::BlockTag::Pending,
            ),
        }
    }
    pub fn set_contract_address(&mut self, address: starknet::core::types::Felt) {
        self.address = address;
    }
    pub fn provider(&self) -> &P {
        &self.provider
    }
    pub fn set_block(&mut self, block_id: starknet::core::types::BlockId) {
        self.block_id = block_id;
    }
    pub fn with_block(self, block_id: starknet::core::types::BlockId) -> Self {
        Self { block_id, ..self }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct ActiveMeetLinkAdded {
    pub meet_link: cainome::cairo_serde::ByteArray,
    pub bootcamp_id: u64,
    pub is_instructor: bool,
    pub org_address: cainome::cairo_serde::ContractAddress,
}
impl cainome::cairo_serde::CairoSerde for ActiveMeetLinkAdded {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(&__rust.meet_link);
        __size += u64::cairo_serialized_size(&__rust.bootcamp_id);
        __size += bool::cairo_serialized_size(&__rust.is_instructor);
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.org_address,
            );
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out
            .extend(cainome::cairo_serde::ByteArray::cairo_serialize(&__rust.meet_link));
        __out.extend(u64::cairo_serialize(&__rust.bootcamp_id));
        __out.extend(bool::cairo_serialize(&__rust.is_instructor));
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    &__rust.org_address,
                ),
            );
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let meet_link = cainome::cairo_serde::ByteArray::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::ByteArray::cairo_serialized_size(&meet_link);
        let bootcamp_id = u64::cairo_deserialize(__felts, __offset)?;
        __offset += u64::cairo_serialized_size(&bootcamp_id);
        let is_instructor = bool::cairo_deserialize(__felts, __offset)?;
        __offset += bool::cairo_serialized_size(&is_instructor);
        let org_address = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &org_address,
            );
        Ok(ActiveMeetLinkAdded {
            meet_link,
            bootcamp_id,
            is_instructor,
            org_address,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct AttendanceMarked {
    pub org_address: cainome::cairo_serde::ContractAddress,
    pub instructor_address: cainome::cairo_serde::ContractAddress,
    pub class_id: u64,
}
impl cainome::cairo_serde::CairoSerde for AttendanceMarked {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.org_address,
            );
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.instructor_address,
            );
        __size += u64::cairo_serialized_size(&__rust.class_id);
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    &__rust.org_address,
                ),
            );
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    &__rust.instructor_address,
                ),
            );
        __out.extend(u64::cairo_serialize(&__rust.class_id));
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let org_address = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &org_address,
            );
        let instructor_address = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &instructor_address,
            );
        let class_id = u64::cairo_deserialize(__felts, __offset)?;
        __offset += u64::cairo_serialized_size(&class_id);
        Ok(AttendanceMarked {
            org_address,
            instructor_address,
            class_id,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct BootCampCreated {
    pub org_name: cainome::cairo_serde::ByteArray,
    pub org_address: cainome::cairo_serde::ContractAddress,
    pub bootcamp_name: cainome::cairo_serde::ByteArray,
    pub nft_name: cainome::cairo_serde::ByteArray,
    pub nft_symbol: cainome::cairo_serde::ByteArray,
    pub nft_uri: cainome::cairo_serde::ByteArray,
    pub num_of_classes: cainome::cairo_serde::U256,
    pub bootcamp_ipfs_uri: cainome::cairo_serde::ByteArray,
}
impl cainome::cairo_serde::CairoSerde for BootCampCreated {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(&__rust.org_name);
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.org_address,
            );
        __size
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(
                &__rust.bootcamp_name,
            );
        __size
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(&__rust.nft_name);
        __size
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(
                &__rust.nft_symbol,
            );
        __size
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(&__rust.nft_uri);
        __size
            += cainome::cairo_serde::U256::cairo_serialized_size(&__rust.num_of_classes);
        __size
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(
                &__rust.bootcamp_ipfs_uri,
            );
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out.extend(cainome::cairo_serde::ByteArray::cairo_serialize(&__rust.org_name));
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    &__rust.org_address,
                ),
            );
        __out
            .extend(
                cainome::cairo_serde::ByteArray::cairo_serialize(&__rust.bootcamp_name),
            );
        __out.extend(cainome::cairo_serde::ByteArray::cairo_serialize(&__rust.nft_name));
        __out
            .extend(
                cainome::cairo_serde::ByteArray::cairo_serialize(&__rust.nft_symbol),
            );
        __out.extend(cainome::cairo_serde::ByteArray::cairo_serialize(&__rust.nft_uri));
        __out
            .extend(cainome::cairo_serde::U256::cairo_serialize(&__rust.num_of_classes));
        __out
            .extend(
                cainome::cairo_serde::ByteArray::cairo_serialize(
                    &__rust.bootcamp_ipfs_uri,
                ),
            );
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let org_name = cainome::cairo_serde::ByteArray::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::ByteArray::cairo_serialized_size(&org_name);
        let org_address = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &org_address,
            );
        let bootcamp_name = cainome::cairo_serde::ByteArray::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(&bootcamp_name);
        let nft_name = cainome::cairo_serde::ByteArray::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::ByteArray::cairo_serialized_size(&nft_name);
        let nft_symbol = cainome::cairo_serde::ByteArray::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::ByteArray::cairo_serialized_size(&nft_symbol);
        let nft_uri = cainome::cairo_serde::ByteArray::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::ByteArray::cairo_serialized_size(&nft_uri);
        let num_of_classes = cainome::cairo_serde::U256::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::U256::cairo_serialized_size(&num_of_classes);
        let bootcamp_ipfs_uri = cainome::cairo_serde::ByteArray::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(
                &bootcamp_ipfs_uri,
            );
        Ok(BootCampCreated {
            org_name,
            org_address,
            bootcamp_name,
            nft_name,
            nft_symbol,
            nft_uri,
            num_of_classes,
            bootcamp_ipfs_uri,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct BootCampSuspended {
    pub org_contract_address: cainome::cairo_serde::ContractAddress,
    pub bootcamp_id: u64,
    pub bootcamp_name: cainome::cairo_serde::ByteArray,
    pub suspended: bool,
}
impl cainome::cairo_serde::CairoSerde for BootCampSuspended {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.org_contract_address,
            );
        __size += u64::cairo_serialized_size(&__rust.bootcamp_id);
        __size
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(
                &__rust.bootcamp_name,
            );
        __size += bool::cairo_serialized_size(&__rust.suspended);
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    &__rust.org_contract_address,
                ),
            );
        __out.extend(u64::cairo_serialize(&__rust.bootcamp_id));
        __out
            .extend(
                cainome::cairo_serde::ByteArray::cairo_serialize(&__rust.bootcamp_name),
            );
        __out.extend(bool::cairo_serialize(&__rust.suspended));
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let org_contract_address = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &org_contract_address,
            );
        let bootcamp_id = u64::cairo_deserialize(__felts, __offset)?;
        __offset += u64::cairo_serialized_size(&bootcamp_id);
        let bootcamp_name = cainome::cairo_serde::ByteArray::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(&bootcamp_name);
        let suspended = bool::cairo_deserialize(__felts, __offset)?;
        __offset += bool::cairo_serialized_size(&suspended);
        Ok(BootCampSuspended {
            org_contract_address,
            bootcamp_id,
            bootcamp_name,
            suspended,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct Bootcamp {
    pub bootcamp_id: u64,
    pub address_of_org: cainome::cairo_serde::ContractAddress,
    pub org_name: cainome::cairo_serde::ByteArray,
    pub bootcamp_name: cainome::cairo_serde::ByteArray,
    pub number_of_instructors: cainome::cairo_serde::U256,
    pub number_of_students: cainome::cairo_serde::U256,
    pub number_of_all_bootcamp_classes: cainome::cairo_serde::U256,
    pub nft_address: cainome::cairo_serde::ContractAddress,
    pub bootcamp_ipfs_uri: cainome::cairo_serde::ByteArray,
    pub active_meet_link: cainome::cairo_serde::ByteArray,
}
impl cainome::cairo_serde::CairoSerde for Bootcamp {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size += u64::cairo_serialized_size(&__rust.bootcamp_id);
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.address_of_org,
            );
        __size
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(&__rust.org_name);
        __size
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(
                &__rust.bootcamp_name,
            );
        __size
            += cainome::cairo_serde::U256::cairo_serialized_size(
                &__rust.number_of_instructors,
            );
        __size
            += cainome::cairo_serde::U256::cairo_serialized_size(
                &__rust.number_of_students,
            );
        __size
            += cainome::cairo_serde::U256::cairo_serialized_size(
                &__rust.number_of_all_bootcamp_classes,
            );
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.nft_address,
            );
        __size
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(
                &__rust.bootcamp_ipfs_uri,
            );
        __size
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(
                &__rust.active_meet_link,
            );
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out.extend(u64::cairo_serialize(&__rust.bootcamp_id));
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    &__rust.address_of_org,
                ),
            );
        __out.extend(cainome::cairo_serde::ByteArray::cairo_serialize(&__rust.org_name));
        __out
            .extend(
                cainome::cairo_serde::ByteArray::cairo_serialize(&__rust.bootcamp_name),
            );
        __out
            .extend(
                cainome::cairo_serde::U256::cairo_serialize(
                    &__rust.number_of_instructors,
                ),
            );
        __out
            .extend(
                cainome::cairo_serde::U256::cairo_serialize(&__rust.number_of_students),
            );
        __out
            .extend(
                cainome::cairo_serde::U256::cairo_serialize(
                    &__rust.number_of_all_bootcamp_classes,
                ),
            );
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    &__rust.nft_address,
                ),
            );
        __out
            .extend(
                cainome::cairo_serde::ByteArray::cairo_serialize(
                    &__rust.bootcamp_ipfs_uri,
                ),
            );
        __out
            .extend(
                cainome::cairo_serde::ByteArray::cairo_serialize(
                    &__rust.active_meet_link,
                ),
            );
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let bootcamp_id = u64::cairo_deserialize(__felts, __offset)?;
        __offset += u64::cairo_serialized_size(&bootcamp_id);
        let address_of_org = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &address_of_org,
            );
        let org_name = cainome::cairo_serde::ByteArray::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::ByteArray::cairo_serialized_size(&org_name);
        let bootcamp_name = cainome::cairo_serde::ByteArray::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(&bootcamp_name);
        let number_of_instructors = cainome::cairo_serde::U256::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::U256::cairo_serialized_size(&number_of_instructors);
        let number_of_students = cainome::cairo_serde::U256::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::U256::cairo_serialized_size(&number_of_students);
        let number_of_all_bootcamp_classes = cainome::cairo_serde::U256::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::U256::cairo_serialized_size(
                &number_of_all_bootcamp_classes,
            );
        let nft_address = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &nft_address,
            );
        let bootcamp_ipfs_uri = cainome::cairo_serde::ByteArray::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(
                &bootcamp_ipfs_uri,
            );
        let active_meet_link = cainome::cairo_serde::ByteArray::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(&active_meet_link);
        Ok(Bootcamp {
            bootcamp_id,
            address_of_org,
            org_name,
            bootcamp_name,
            number_of_instructors,
            number_of_students,
            number_of_all_bootcamp_classes,
            nft_address,
            bootcamp_ipfs_uri,
            active_meet_link,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct BootcampRegistration {
    pub org_address: cainome::cairo_serde::ContractAddress,
    pub bootcamp_id: u64,
}
impl cainome::cairo_serde::CairoSerde for BootcampRegistration {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.org_address,
            );
        __size += u64::cairo_serialized_size(&__rust.bootcamp_id);
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    &__rust.org_address,
                ),
            );
        __out.extend(u64::cairo_serialize(&__rust.bootcamp_id));
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let org_address = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &org_address,
            );
        let bootcamp_id = u64::cairo_deserialize(__felts, __offset)?;
        __offset += u64::cairo_serialized_size(&bootcamp_id);
        Ok(BootcampRegistration {
            org_address,
            bootcamp_id,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct Class {
    pub address_of_org: cainome::cairo_serde::ContractAddress,
    pub instructor: cainome::cairo_serde::ContractAddress,
    pub num_of_reg_students: u32,
    pub active_status: bool,
    pub bootcamp_id: u64,
}
impl cainome::cairo_serde::CairoSerde for Class {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.address_of_org,
            );
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.instructor,
            );
        __size += u32::cairo_serialized_size(&__rust.num_of_reg_students);
        __size += bool::cairo_serialized_size(&__rust.active_status);
        __size += u64::cairo_serialized_size(&__rust.bootcamp_id);
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    &__rust.address_of_org,
                ),
            );
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    &__rust.instructor,
                ),
            );
        __out.extend(u32::cairo_serialize(&__rust.num_of_reg_students));
        __out.extend(bool::cairo_serialize(&__rust.active_status));
        __out.extend(u64::cairo_serialize(&__rust.bootcamp_id));
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let address_of_org = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &address_of_org,
            );
        let instructor = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&instructor);
        let num_of_reg_students = u32::cairo_deserialize(__felts, __offset)?;
        __offset += u32::cairo_serialized_size(&num_of_reg_students);
        let active_status = bool::cairo_deserialize(__felts, __offset)?;
        __offset += bool::cairo_serialized_size(&active_status);
        let bootcamp_id = u64::cairo_deserialize(__felts, __offset)?;
        __offset += u64::cairo_serialized_size(&bootcamp_id);
        Ok(Class {
            address_of_org,
            instructor,
            num_of_reg_students,
            active_status,
            bootcamp_id,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct Instructor {
    pub address_of_instructor: cainome::cairo_serde::ContractAddress,
    pub num_of_classes: cainome::cairo_serde::U256,
    pub name_of_org: cainome::cairo_serde::ByteArray,
    pub organization_address: cainome::cairo_serde::ContractAddress,
}
impl cainome::cairo_serde::CairoSerde for Instructor {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.address_of_instructor,
            );
        __size
            += cainome::cairo_serde::U256::cairo_serialized_size(&__rust.num_of_classes);
        __size
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(
                &__rust.name_of_org,
            );
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.organization_address,
            );
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    &__rust.address_of_instructor,
                ),
            );
        __out
            .extend(cainome::cairo_serde::U256::cairo_serialize(&__rust.num_of_classes));
        __out
            .extend(
                cainome::cairo_serde::ByteArray::cairo_serialize(&__rust.name_of_org),
            );
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    &__rust.organization_address,
                ),
            );
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let address_of_instructor = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &address_of_instructor,
            );
        let num_of_classes = cainome::cairo_serde::U256::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::U256::cairo_serialized_size(&num_of_classes);
        let name_of_org = cainome::cairo_serde::ByteArray::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::ByteArray::cairo_serialized_size(&name_of_org);
        let organization_address = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &organization_address,
            );
        Ok(Instructor {
            address_of_instructor,
            num_of_classes,
            name_of_org,
            organization_address,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct InstructorAddedToOrg {
    pub org_name: cainome::cairo_serde::ByteArray,
    pub org_address: cainome::cairo_serde::ContractAddress,
    pub instructor: Vec<cainome::cairo_serde::ContractAddress>,
}
impl cainome::cairo_serde::CairoSerde for InstructorAddedToOrg {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(&__rust.org_name);
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.org_address,
            );
        __size
            += Vec::<
                cainome::cairo_serde::ContractAddress,
            >::cairo_serialized_size(&__rust.instructor);
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out.extend(cainome::cairo_serde::ByteArray::cairo_serialize(&__rust.org_name));
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    &__rust.org_address,
                ),
            );
        __out
            .extend(
                Vec::<
                    cainome::cairo_serde::ContractAddress,
                >::cairo_serialize(&__rust.instructor),
            );
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let org_name = cainome::cairo_serde::ByteArray::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::ByteArray::cairo_serialized_size(&org_name);
        let org_address = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &org_address,
            );
        let instructor = Vec::<
            cainome::cairo_serde::ContractAddress,
        >::cairo_deserialize(__felts, __offset)?;
        __offset
            += Vec::<
                cainome::cairo_serde::ContractAddress,
            >::cairo_serialized_size(&instructor);
        Ok(InstructorAddedToOrg {
            org_name,
            org_address,
            instructor,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct InstructorRemovedFromOrg {
    pub instructor_addr: cainome::cairo_serde::ContractAddress,
    pub org_owner: cainome::cairo_serde::ContractAddress,
}
impl cainome::cairo_serde::CairoSerde for InstructorRemovedFromOrg {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.instructor_addr,
            );
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.org_owner,
            );
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    &__rust.instructor_addr,
                ),
            );
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(&__rust.org_owner),
            );
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let instructor_addr = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &instructor_addr,
            );
        let org_owner = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&org_owner);
        Ok(InstructorRemovedFromOrg {
            instructor_addr,
            org_owner,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct Organization {
    pub address_of_org: cainome::cairo_serde::ContractAddress,
    pub org_name: cainome::cairo_serde::ByteArray,
    pub number_of_instructors: cainome::cairo_serde::U256,
    pub number_of_students: cainome::cairo_serde::U256,
    pub number_of_all_classes: cainome::cairo_serde::U256,
    pub number_of_all_bootcamps: cainome::cairo_serde::U256,
    pub org_ipfs_uri: cainome::cairo_serde::ByteArray,
    pub total_sponsorship_fund: cainome::cairo_serde::U256,
}
impl cainome::cairo_serde::CairoSerde for Organization {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.address_of_org,
            );
        __size
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(&__rust.org_name);
        __size
            += cainome::cairo_serde::U256::cairo_serialized_size(
                &__rust.number_of_instructors,
            );
        __size
            += cainome::cairo_serde::U256::cairo_serialized_size(
                &__rust.number_of_students,
            );
        __size
            += cainome::cairo_serde::U256::cairo_serialized_size(
                &__rust.number_of_all_classes,
            );
        __size
            += cainome::cairo_serde::U256::cairo_serialized_size(
                &__rust.number_of_all_bootcamps,
            );
        __size
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(
                &__rust.org_ipfs_uri,
            );
        __size
            += cainome::cairo_serde::U256::cairo_serialized_size(
                &__rust.total_sponsorship_fund,
            );
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    &__rust.address_of_org,
                ),
            );
        __out.extend(cainome::cairo_serde::ByteArray::cairo_serialize(&__rust.org_name));
        __out
            .extend(
                cainome::cairo_serde::U256::cairo_serialize(
                    &__rust.number_of_instructors,
                ),
            );
        __out
            .extend(
                cainome::cairo_serde::U256::cairo_serialize(&__rust.number_of_students),
            );
        __out
            .extend(
                cainome::cairo_serde::U256::cairo_serialize(
                    &__rust.number_of_all_classes,
                ),
            );
        __out
            .extend(
                cainome::cairo_serde::U256::cairo_serialize(
                    &__rust.number_of_all_bootcamps,
                ),
            );
        __out
            .extend(
                cainome::cairo_serde::ByteArray::cairo_serialize(&__rust.org_ipfs_uri),
            );
        __out
            .extend(
                cainome::cairo_serde::U256::cairo_serialize(
                    &__rust.total_sponsorship_fund,
                ),
            );
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let address_of_org = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &address_of_org,
            );
        let org_name = cainome::cairo_serde::ByteArray::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::ByteArray::cairo_serialized_size(&org_name);
        let number_of_instructors = cainome::cairo_serde::U256::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::U256::cairo_serialized_size(&number_of_instructors);
        let number_of_students = cainome::cairo_serde::U256::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::U256::cairo_serialized_size(&number_of_students);
        let number_of_all_classes = cainome::cairo_serde::U256::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::U256::cairo_serialized_size(&number_of_all_classes);
        let number_of_all_bootcamps = cainome::cairo_serde::U256::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::U256::cairo_serialized_size(
                &number_of_all_bootcamps,
            );
        let org_ipfs_uri = cainome::cairo_serde::ByteArray::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(&org_ipfs_uri);
        let total_sponsorship_fund = cainome::cairo_serde::U256::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::U256::cairo_serialized_size(
                &total_sponsorship_fund,
            );
        Ok(Organization {
            address_of_org,
            org_name,
            number_of_instructors,
            number_of_students,
            number_of_all_classes,
            number_of_all_bootcamps,
            org_ipfs_uri,
            total_sponsorship_fund,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct OrganizationProfile {
    pub org_name: cainome::cairo_serde::ByteArray,
    pub org_ipfs_uri: cainome::cairo_serde::ByteArray,
}
impl cainome::cairo_serde::CairoSerde for OrganizationProfile {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(&__rust.org_name);
        __size
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(
                &__rust.org_ipfs_uri,
            );
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out.extend(cainome::cairo_serde::ByteArray::cairo_serialize(&__rust.org_name));
        __out
            .extend(
                cainome::cairo_serde::ByteArray::cairo_serialize(&__rust.org_ipfs_uri),
            );
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let org_name = cainome::cairo_serde::ByteArray::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::ByteArray::cairo_serialized_size(&org_name);
        let org_ipfs_uri = cainome::cairo_serde::ByteArray::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(&org_ipfs_uri);
        Ok(OrganizationProfile {
            org_name,
            org_ipfs_uri,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct OrganizationSponsored {
    pub organization_address: cainome::cairo_serde::ContractAddress,
    pub sponsor_uri: cainome::cairo_serde::ByteArray,
    pub sponsorship_amount: cainome::cairo_serde::U256,
}
impl cainome::cairo_serde::CairoSerde for OrganizationSponsored {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.organization_address,
            );
        __size
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(
                &__rust.sponsor_uri,
            );
        __size
            += cainome::cairo_serde::U256::cairo_serialized_size(
                &__rust.sponsorship_amount,
            );
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    &__rust.organization_address,
                ),
            );
        __out
            .extend(
                cainome::cairo_serde::ByteArray::cairo_serialize(&__rust.sponsor_uri),
            );
        __out
            .extend(
                cainome::cairo_serde::U256::cairo_serialize(&__rust.sponsorship_amount),
            );
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let organization_address = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &organization_address,
            );
        let sponsor_uri = cainome::cairo_serde::ByteArray::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::ByteArray::cairo_serialized_size(&sponsor_uri);
        let sponsorship_amount = cainome::cairo_serde::U256::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::U256::cairo_serialized_size(&sponsorship_amount);
        Ok(OrganizationSponsored {
            organization_address,
            sponsor_uri,
            sponsorship_amount,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct OrganizationSuspended {
    pub org_contract_address: cainome::cairo_serde::ContractAddress,
    pub org_name: cainome::cairo_serde::ByteArray,
    pub suspended: bool,
}
impl cainome::cairo_serde::CairoSerde for OrganizationSuspended {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.org_contract_address,
            );
        __size
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(&__rust.org_name);
        __size += bool::cairo_serialized_size(&__rust.suspended);
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    &__rust.org_contract_address,
                ),
            );
        __out.extend(cainome::cairo_serde::ByteArray::cairo_serialize(&__rust.org_name));
        __out.extend(bool::cairo_serialize(&__rust.suspended));
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let org_contract_address = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &org_contract_address,
            );
        let org_name = cainome::cairo_serde::ByteArray::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::ByteArray::cairo_serialized_size(&org_name);
        let suspended = bool::cairo_deserialize(__felts, __offset)?;
        __offset += bool::cairo_serialized_size(&suspended);
        Ok(OrganizationSuspended {
            org_contract_address,
            org_name,
            suspended,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct OwnershipTransferStarted {
    pub previous_owner: cainome::cairo_serde::ContractAddress,
    pub new_owner: cainome::cairo_serde::ContractAddress,
}
impl cainome::cairo_serde::CairoSerde for OwnershipTransferStarted {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.previous_owner,
            );
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.new_owner,
            );
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    &__rust.previous_owner,
                ),
            );
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(&__rust.new_owner),
            );
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let previous_owner = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &previous_owner,
            );
        let new_owner = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&new_owner);
        Ok(OwnershipTransferStarted {
            previous_owner,
            new_owner,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct OwnershipTransferred {
    pub previous_owner: cainome::cairo_serde::ContractAddress,
    pub new_owner: cainome::cairo_serde::ContractAddress,
}
impl cainome::cairo_serde::CairoSerde for OwnershipTransferred {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.previous_owner,
            );
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.new_owner,
            );
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    &__rust.previous_owner,
                ),
            );
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(&__rust.new_owner),
            );
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let previous_owner = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &previous_owner,
            );
        let new_owner = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&new_owner);
        Ok(OwnershipTransferred {
            previous_owner,
            new_owner,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct RegisteredBootcamp {
    pub address_of_org: cainome::cairo_serde::ContractAddress,
    pub student: cainome::cairo_serde::ContractAddress,
    pub acceptance_status: bool,
    pub bootcamp_id: u64,
}
impl cainome::cairo_serde::CairoSerde for RegisteredBootcamp {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.address_of_org,
            );
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.student,
            );
        __size += bool::cairo_serialized_size(&__rust.acceptance_status);
        __size += u64::cairo_serialized_size(&__rust.bootcamp_id);
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    &__rust.address_of_org,
                ),
            );
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(&__rust.student),
            );
        __out.extend(bool::cairo_serialize(&__rust.acceptance_status));
        __out.extend(u64::cairo_serialize(&__rust.bootcamp_id));
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let address_of_org = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &address_of_org,
            );
        let student = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&student);
        let acceptance_status = bool::cairo_deserialize(__felts, __offset)?;
        __offset += bool::cairo_serialized_size(&acceptance_status);
        let bootcamp_id = u64::cairo_deserialize(__felts, __offset)?;
        __offset += u64::cairo_serialized_size(&bootcamp_id);
        Ok(RegisteredBootcamp {
            address_of_org,
            student,
            acceptance_status,
            bootcamp_id,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct RegistrationApproved {
    pub student_address: cainome::cairo_serde::ContractAddress,
    pub bootcamp_id: u64,
}
impl cainome::cairo_serde::CairoSerde for RegistrationApproved {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.student_address,
            );
        __size += u64::cairo_serialized_size(&__rust.bootcamp_id);
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    &__rust.student_address,
                ),
            );
        __out.extend(u64::cairo_serialize(&__rust.bootcamp_id));
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let student_address = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &student_address,
            );
        let bootcamp_id = u64::cairo_deserialize(__felts, __offset)?;
        __offset += u64::cairo_serialized_size(&bootcamp_id);
        Ok(RegistrationApproved {
            student_address,
            bootcamp_id,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct RegistrationDeclined {
    pub student_address: cainome::cairo_serde::ContractAddress,
    pub bootcamp_id: u64,
}
impl cainome::cairo_serde::CairoSerde for RegistrationDeclined {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.student_address,
            );
        __size += u64::cairo_serialized_size(&__rust.bootcamp_id);
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    &__rust.student_address,
                ),
            );
        __out.extend(u64::cairo_serialize(&__rust.bootcamp_id));
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let student_address = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &student_address,
            );
        let bootcamp_id = u64::cairo_deserialize(__felts, __offset)?;
        __offset += u64::cairo_serialized_size(&bootcamp_id);
        Ok(RegistrationDeclined {
            student_address,
            bootcamp_id,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct Sponsor {
    pub amt: cainome::cairo_serde::U256,
    pub uri: cainome::cairo_serde::ByteArray,
    pub organization: cainome::cairo_serde::ContractAddress,
}
impl cainome::cairo_serde::CairoSerde for Sponsor {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size += cainome::cairo_serde::U256::cairo_serialized_size(&__rust.amt);
        __size += cainome::cairo_serde::ByteArray::cairo_serialized_size(&__rust.uri);
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.organization,
            );
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out.extend(cainome::cairo_serde::U256::cairo_serialize(&__rust.amt));
        __out.extend(cainome::cairo_serde::ByteArray::cairo_serialize(&__rust.uri));
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    &__rust.organization,
                ),
            );
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let amt = cainome::cairo_serde::U256::cairo_deserialize(__felts, __offset)?;
        __offset += cainome::cairo_serde::U256::cairo_serialized_size(&amt);
        let uri = cainome::cairo_serde::ByteArray::cairo_deserialize(__felts, __offset)?;
        __offset += cainome::cairo_serde::ByteArray::cairo_serialized_size(&uri);
        let organization = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &organization,
            );
        Ok(Sponsor { amt, uri, organization })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct SponsorshipAddressSet {
    pub sponsor_contract_address: cainome::cairo_serde::ContractAddress,
}
impl cainome::cairo_serde::CairoSerde for SponsorshipAddressSet {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.sponsor_contract_address,
            );
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    &__rust.sponsor_contract_address,
                ),
            );
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let sponsor_contract_address = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &sponsor_contract_address,
            );
        Ok(SponsorshipAddressSet {
            sponsor_contract_address,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct SponsorshipFundWithdrawn {
    pub withdrawal_amount: cainome::cairo_serde::U256,
}
impl cainome::cairo_serde::CairoSerde for SponsorshipFundWithdrawn {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += cainome::cairo_serde::U256::cairo_serialized_size(
                &__rust.withdrawal_amount,
            );
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out
            .extend(
                cainome::cairo_serde::U256::cairo_serialize(&__rust.withdrawal_amount),
            );
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let withdrawal_amount = cainome::cairo_serde::U256::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::U256::cairo_serialized_size(&withdrawal_amount);
        Ok(SponsorshipFundWithdrawn {
            withdrawal_amount,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct Student {
    pub address_of_student: cainome::cairo_serde::ContractAddress,
    pub num_of_bootcamps_registered_for: cainome::cairo_serde::U256,
    pub status: u8,
    pub student_details_uri: cainome::cairo_serde::ByteArray,
}
impl cainome::cairo_serde::CairoSerde for Student {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.address_of_student,
            );
        __size
            += cainome::cairo_serde::U256::cairo_serialized_size(
                &__rust.num_of_bootcamps_registered_for,
            );
        __size += u8::cairo_serialized_size(&__rust.status);
        __size
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(
                &__rust.student_details_uri,
            );
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    &__rust.address_of_student,
                ),
            );
        __out
            .extend(
                cainome::cairo_serde::U256::cairo_serialize(
                    &__rust.num_of_bootcamps_registered_for,
                ),
            );
        __out.extend(u8::cairo_serialize(&__rust.status));
        __out
            .extend(
                cainome::cairo_serde::ByteArray::cairo_serialize(
                    &__rust.student_details_uri,
                ),
            );
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let address_of_student = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &address_of_student,
            );
        let num_of_bootcamps_registered_for = cainome::cairo_serde::U256::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::U256::cairo_serialized_size(
                &num_of_bootcamps_registered_for,
            );
        let status = u8::cairo_deserialize(__felts, __offset)?;
        __offset += u8::cairo_serialized_size(&status);
        let student_details_uri = cainome::cairo_serde::ByteArray::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(
                &student_details_uri,
            );
        Ok(Student {
            address_of_student,
            num_of_bootcamps_registered_for,
            status,
            student_details_uri,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct StudentsCertified {
    pub org_address: cainome::cairo_serde::ContractAddress,
    pub class_id: u64,
    pub student_addresses: Vec<cainome::cairo_serde::ContractAddress>,
}
impl cainome::cairo_serde::CairoSerde for StudentsCertified {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.org_address,
            );
        __size += u64::cairo_serialized_size(&__rust.class_id);
        __size
            += Vec::<
                cainome::cairo_serde::ContractAddress,
            >::cairo_serialized_size(&__rust.student_addresses);
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    &__rust.org_address,
                ),
            );
        __out.extend(u64::cairo_serialize(&__rust.class_id));
        __out
            .extend(
                Vec::<
                    cainome::cairo_serde::ContractAddress,
                >::cairo_serialize(&__rust.student_addresses),
            );
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let org_address = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &org_address,
            );
        let class_id = u64::cairo_deserialize(__felts, __offset)?;
        __offset += u64::cairo_serialized_size(&class_id);
        let student_addresses = Vec::<
            cainome::cairo_serde::ContractAddress,
        >::cairo_deserialize(__felts, __offset)?;
        __offset
            += Vec::<
                cainome::cairo_serde::ContractAddress,
            >::cairo_serialized_size(&student_addresses);
        Ok(StudentsCertified {
            org_address,
            class_id,
            student_addresses,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct Upgraded {
    pub class_hash: cainome::cairo_serde::ClassHash,
}
impl cainome::cairo_serde::CairoSerde for Upgraded {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += cainome::cairo_serde::ClassHash::cairo_serialized_size(
                &__rust.class_hash,
            );
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out
            .extend(
                cainome::cairo_serde::ClassHash::cairo_serialize(&__rust.class_hash),
            );
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let class_hash = cainome::cairo_serde::ClassHash::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::ClassHash::cairo_serialized_size(&class_hash);
        Ok(Upgraded { class_hash })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct VideoLinkUploaded {
    pub video_link: cainome::cairo_serde::ByteArray,
    pub is_instructor: bool,
    pub org_address: cainome::cairo_serde::ContractAddress,
    pub bootcamp_id: u64,
}
impl cainome::cairo_serde::CairoSerde for VideoLinkUploaded {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(
                &__rust.video_link,
            );
        __size += bool::cairo_serialized_size(&__rust.is_instructor);
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.org_address,
            );
        __size += u64::cairo_serialized_size(&__rust.bootcamp_id);
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out
            .extend(
                cainome::cairo_serde::ByteArray::cairo_serialize(&__rust.video_link),
            );
        __out.extend(bool::cairo_serialize(&__rust.is_instructor));
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    &__rust.org_address,
                ),
            );
        __out.extend(u64::cairo_serialize(&__rust.bootcamp_id));
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let video_link = cainome::cairo_serde::ByteArray::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::ByteArray::cairo_serialized_size(&video_link);
        let is_instructor = bool::cairo_deserialize(__felts, __offset)?;
        __offset += bool::cairo_serialized_size(&is_instructor);
        let org_address = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &org_address,
            );
        let bootcamp_id = u64::cairo_deserialize(__felts, __offset)?;
        __offset += u64::cairo_serialized_size(&bootcamp_id);
        Ok(VideoLinkUploaded {
            video_link,
            is_instructor,
            org_address,
            bootcamp_id,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct Withdrawn {
    pub amt: cainome::cairo_serde::U256,
    pub organization: cainome::cairo_serde::ContractAddress,
}
impl cainome::cairo_serde::CairoSerde for Withdrawn {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size += cainome::cairo_serde::U256::cairo_serialized_size(&__rust.amt);
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.organization,
            );
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out.extend(cainome::cairo_serde::U256::cairo_serialize(&__rust.amt));
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    &__rust.organization,
                ),
            );
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let amt = cainome::cairo_serde::U256::cairo_deserialize(__felts, __offset)?;
        __offset += cainome::cairo_serde::U256::cairo_serialized_size(&amt);
        let organization = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &organization,
            );
        Ok(Withdrawn { amt, organization })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub enum Event {
    Sponsor(Sponsor),
    Withdrawn(Withdrawn),
    OrganizationProfile(OrganizationProfile),
    InstructorAddedToOrg(InstructorAddedToOrg),
    InstructorRemovedFromOrg(InstructorRemovedFromOrg),
    BootCampCreated(BootCampCreated),
    ActiveMeetLinkAdded(ActiveMeetLinkAdded),
    VideoLinkUploaded(VideoLinkUploaded),
    BootcampRegistration(BootcampRegistration),
    RegistrationApproved(RegistrationApproved),
    RegistrationDeclined(RegistrationDeclined),
    AttendanceMarked(AttendanceMarked),
    StudentsCertified(StudentsCertified),
    SponsorshipAddressSet(SponsorshipAddressSet),
    OrganizationSponsored(OrganizationSponsored),
    SponsorshipFundWithdrawn(SponsorshipFundWithdrawn),
    OrganizationSuspended(OrganizationSuspended),
    BootCampSuspended(BootCampSuspended),
    OwnableEvent(OwnableComponentEvent),
    UpgradeableEvent(UpgradeableComponentEvent),
}
impl cainome::cairo_serde::CairoSerde for Event {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = std::option::Option::None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        match __rust {
            Event::Sponsor(val) => Sponsor::cairo_serialized_size(val) + 1,
            Event::Withdrawn(val) => Withdrawn::cairo_serialized_size(val) + 1,
            Event::OrganizationProfile(val) => {
                OrganizationProfile::cairo_serialized_size(val) + 1
            }
            Event::InstructorAddedToOrg(val) => {
                InstructorAddedToOrg::cairo_serialized_size(val) + 1
            }
            Event::InstructorRemovedFromOrg(val) => {
                InstructorRemovedFromOrg::cairo_serialized_size(val) + 1
            }
            Event::BootCampCreated(val) => {
                BootCampCreated::cairo_serialized_size(val) + 1
            }
            Event::ActiveMeetLinkAdded(val) => {
                ActiveMeetLinkAdded::cairo_serialized_size(val) + 1
            }
            Event::VideoLinkUploaded(val) => {
                VideoLinkUploaded::cairo_serialized_size(val) + 1
            }
            Event::BootcampRegistration(val) => {
                BootcampRegistration::cairo_serialized_size(val) + 1
            }
            Event::RegistrationApproved(val) => {
                RegistrationApproved::cairo_serialized_size(val) + 1
            }
            Event::RegistrationDeclined(val) => {
                RegistrationDeclined::cairo_serialized_size(val) + 1
            }
            Event::AttendanceMarked(val) => {
                AttendanceMarked::cairo_serialized_size(val) + 1
            }
            Event::StudentsCertified(val) => {
                StudentsCertified::cairo_serialized_size(val) + 1
            }
            Event::SponsorshipAddressSet(val) => {
                SponsorshipAddressSet::cairo_serialized_size(val) + 1
            }
            Event::OrganizationSponsored(val) => {
                OrganizationSponsored::cairo_serialized_size(val) + 1
            }
            Event::SponsorshipFundWithdrawn(val) => {
                SponsorshipFundWithdrawn::cairo_serialized_size(val) + 1
            }
            Event::OrganizationSuspended(val) => {
                OrganizationSuspended::cairo_serialized_size(val) + 1
            }
            Event::BootCampSuspended(val) => {
                BootCampSuspended::cairo_serialized_size(val) + 1
            }
            Event::OwnableEvent(val) => {
                OwnableComponentEvent::cairo_serialized_size(val) + 1
            }
            Event::UpgradeableEvent(val) => {
                UpgradeableComponentEvent::cairo_serialized_size(val) + 1
            }
            _ => 0,
        }
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        match __rust {
            Event::Sponsor(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&0usize));
                temp.extend(Sponsor::cairo_serialize(val));
                temp
            }
            Event::Withdrawn(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&1usize));
                temp.extend(Withdrawn::cairo_serialize(val));
                temp
            }
            Event::OrganizationProfile(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&2usize));
                temp.extend(OrganizationProfile::cairo_serialize(val));
                temp
            }
            Event::InstructorAddedToOrg(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&3usize));
                temp.extend(InstructorAddedToOrg::cairo_serialize(val));
                temp
            }
            Event::InstructorRemovedFromOrg(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&4usize));
                temp.extend(InstructorRemovedFromOrg::cairo_serialize(val));
                temp
            }
            Event::BootCampCreated(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&5usize));
                temp.extend(BootCampCreated::cairo_serialize(val));
                temp
            }
            Event::ActiveMeetLinkAdded(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&6usize));
                temp.extend(ActiveMeetLinkAdded::cairo_serialize(val));
                temp
            }
            Event::VideoLinkUploaded(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&7usize));
                temp.extend(VideoLinkUploaded::cairo_serialize(val));
                temp
            }
            Event::BootcampRegistration(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&8usize));
                temp.extend(BootcampRegistration::cairo_serialize(val));
                temp
            }
            Event::RegistrationApproved(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&9usize));
                temp.extend(RegistrationApproved::cairo_serialize(val));
                temp
            }
            Event::RegistrationDeclined(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&10usize));
                temp.extend(RegistrationDeclined::cairo_serialize(val));
                temp
            }
            Event::AttendanceMarked(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&11usize));
                temp.extend(AttendanceMarked::cairo_serialize(val));
                temp
            }
            Event::StudentsCertified(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&12usize));
                temp.extend(StudentsCertified::cairo_serialize(val));
                temp
            }
            Event::SponsorshipAddressSet(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&13usize));
                temp.extend(SponsorshipAddressSet::cairo_serialize(val));
                temp
            }
            Event::OrganizationSponsored(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&14usize));
                temp.extend(OrganizationSponsored::cairo_serialize(val));
                temp
            }
            Event::SponsorshipFundWithdrawn(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&15usize));
                temp.extend(SponsorshipFundWithdrawn::cairo_serialize(val));
                temp
            }
            Event::OrganizationSuspended(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&16usize));
                temp.extend(OrganizationSuspended::cairo_serialize(val));
                temp
            }
            Event::BootCampSuspended(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&17usize));
                temp.extend(BootCampSuspended::cairo_serialize(val));
                temp
            }
            Event::OwnableEvent(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&18usize));
                temp.extend(OwnableComponentEvent::cairo_serialize(val));
                temp
            }
            Event::UpgradeableEvent(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&19usize));
                temp.extend(UpgradeableComponentEvent::cairo_serialize(val));
                temp
            }
            _ => vec![],
        }
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let __f = __felts[__offset];
        let __index = u128::from_be_bytes(__f.to_bytes_be()[16..].try_into().unwrap());
        match __index as usize {
            0usize => {
                Ok(Event::Sponsor(Sponsor::cairo_deserialize(__felts, __offset + 1)?))
            }
            1usize => {
                Ok(
                    Event::Withdrawn(
                        Withdrawn::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            2usize => {
                Ok(
                    Event::OrganizationProfile(
                        OrganizationProfile::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            3usize => {
                Ok(
                    Event::InstructorAddedToOrg(
                        InstructorAddedToOrg::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            4usize => {
                Ok(
                    Event::InstructorRemovedFromOrg(
                        InstructorRemovedFromOrg::cairo_deserialize(
                            __felts,
                            __offset + 1,
                        )?,
                    ),
                )
            }
            5usize => {
                Ok(
                    Event::BootCampCreated(
                        BootCampCreated::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            6usize => {
                Ok(
                    Event::ActiveMeetLinkAdded(
                        ActiveMeetLinkAdded::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            7usize => {
                Ok(
                    Event::VideoLinkUploaded(
                        VideoLinkUploaded::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            8usize => {
                Ok(
                    Event::BootcampRegistration(
                        BootcampRegistration::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            9usize => {
                Ok(
                    Event::RegistrationApproved(
                        RegistrationApproved::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            10usize => {
                Ok(
                    Event::RegistrationDeclined(
                        RegistrationDeclined::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            11usize => {
                Ok(
                    Event::AttendanceMarked(
                        AttendanceMarked::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            12usize => {
                Ok(
                    Event::StudentsCertified(
                        StudentsCertified::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            13usize => {
                Ok(
                    Event::SponsorshipAddressSet(
                        SponsorshipAddressSet::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            14usize => {
                Ok(
                    Event::OrganizationSponsored(
                        OrganizationSponsored::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            15usize => {
                Ok(
                    Event::SponsorshipFundWithdrawn(
                        SponsorshipFundWithdrawn::cairo_deserialize(
                            __felts,
                            __offset + 1,
                        )?,
                    ),
                )
            }
            16usize => {
                Ok(
                    Event::OrganizationSuspended(
                        OrganizationSuspended::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            17usize => {
                Ok(
                    Event::BootCampSuspended(
                        BootCampSuspended::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            18usize => {
                Ok(
                    Event::OwnableEvent(
                        OwnableComponentEvent::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            19usize => {
                Ok(
                    Event::UpgradeableEvent(
                        UpgradeableComponentEvent::cairo_deserialize(
                            __felts,
                            __offset + 1,
                        )?,
                    ),
                )
            }
            _ => {
                return Err(
                    cainome::cairo_serde::Error::Deserialize(
                        format!("Index not handle for enum {}", "Event"),
                    ),
                );
            }
        }
    }
}
impl TryFrom<starknet::core::types::EmittedEvent> for Event {
    type Error = String;
    fn try_from(
        event: starknet::core::types::EmittedEvent,
    ) -> Result<Self, Self::Error> {
        use cainome::cairo_serde::CairoSerde;
        if event.keys.is_empty() {
            return Err("Event has no key".to_string());
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("Sponsor")
                .unwrap_or_else(|_| panic!("Invalid selector for {}", "Sponsor"))
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let amt = match cainome::cairo_serde::U256::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "amt",
                            "Sponsor", e
                        ),
                    );
                }
            };
            data_offset += cainome::cairo_serde::U256::cairo_serialized_size(&amt);
            let uri = match cainome::cairo_serde::ByteArray::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "uri",
                            "Sponsor", e
                        ),
                    );
                }
            };
            data_offset += cainome::cairo_serde::ByteArray::cairo_serialized_size(&uri);
            let organization = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "organization", "Sponsor", e
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &organization,
                );
            return Ok(Event::Sponsor(Sponsor { amt, uri, organization }));
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("Withdrawn")
                .unwrap_or_else(|_| panic!("Invalid selector for {}", "Withdrawn"))
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let amt = match cainome::cairo_serde::U256::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "amt",
                            "Withdrawn", e
                        ),
                    );
                }
            };
            data_offset += cainome::cairo_serde::U256::cairo_serialized_size(&amt);
            let organization = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "organization", "Withdrawn", e
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &organization,
                );
            return Ok(Event::Withdrawn(Withdrawn { amt, organization }));
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("OrganizationProfile")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "OrganizationProfile")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let org_name = match cainome::cairo_serde::ByteArray::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "org_name",
                            "OrganizationProfile", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ByteArray::cairo_serialized_size(&org_name);
            let org_ipfs_uri = match cainome::cairo_serde::ByteArray::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "org_ipfs_uri", "OrganizationProfile", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ByteArray::cairo_serialized_size(&org_ipfs_uri);
            return Ok(
                Event::OrganizationProfile(OrganizationProfile {
                    org_name,
                    org_ipfs_uri,
                }),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("InstructorAddedToOrg")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "InstructorAddedToOrg")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let org_name = match cainome::cairo_serde::ByteArray::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "org_name",
                            "InstructorAddedToOrg", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ByteArray::cairo_serialized_size(&org_name);
            let org_address = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "org_address",
                            "InstructorAddedToOrg", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &org_address,
                );
            let instructor = match Vec::<
                cainome::cairo_serde::ContractAddress,
            >::cairo_deserialize(&event.keys, key_offset) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "instructor",
                            "InstructorAddedToOrg", e
                        ),
                    );
                }
            };
            key_offset
                += Vec::<
                    cainome::cairo_serde::ContractAddress,
                >::cairo_serialized_size(&instructor);
            return Ok(
                Event::InstructorAddedToOrg(InstructorAddedToOrg {
                    org_name,
                    org_address,
                    instructor,
                }),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("InstructorRemovedFromOrg")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "InstructorRemovedFromOrg")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let instructor_addr = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "instructor_addr", "InstructorRemovedFromOrg", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &instructor_addr,
                );
            let org_owner = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "org_owner",
                            "InstructorRemovedFromOrg", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &org_owner,
                );
            return Ok(
                Event::InstructorRemovedFromOrg(InstructorRemovedFromOrg {
                    instructor_addr,
                    org_owner,
                }),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("BootCampCreated")
                .unwrap_or_else(|_| panic!("Invalid selector for {}", "BootCampCreated"))
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let org_name = match cainome::cairo_serde::ByteArray::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "org_name",
                            "BootCampCreated", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ByteArray::cairo_serialized_size(&org_name);
            let org_address = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "org_address",
                            "BootCampCreated", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &org_address,
                );
            let bootcamp_name = match cainome::cairo_serde::ByteArray::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "bootcamp_name", "BootCampCreated", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ByteArray::cairo_serialized_size(
                    &bootcamp_name,
                );
            let nft_name = match cainome::cairo_serde::ByteArray::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "nft_name",
                            "BootCampCreated", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ByteArray::cairo_serialized_size(&nft_name);
            let nft_symbol = match cainome::cairo_serde::ByteArray::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "nft_symbol",
                            "BootCampCreated", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ByteArray::cairo_serialized_size(&nft_symbol);
            let nft_uri = match cainome::cairo_serde::ByteArray::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "nft_uri",
                            "BootCampCreated", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ByteArray::cairo_serialized_size(&nft_uri);
            let num_of_classes = match cainome::cairo_serde::U256::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "num_of_classes", "BootCampCreated", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::U256::cairo_serialized_size(&num_of_classes);
            let bootcamp_ipfs_uri = match cainome::cairo_serde::ByteArray::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "bootcamp_ipfs_uri", "BootCampCreated", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ByteArray::cairo_serialized_size(
                    &bootcamp_ipfs_uri,
                );
            return Ok(
                Event::BootCampCreated(BootCampCreated {
                    org_name,
                    org_address,
                    bootcamp_name,
                    nft_name,
                    nft_symbol,
                    nft_uri,
                    num_of_classes,
                    bootcamp_ipfs_uri,
                }),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("ActiveMeetLinkAdded")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "ActiveMeetLinkAdded")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let meet_link = match cainome::cairo_serde::ByteArray::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "meet_link",
                            "ActiveMeetLinkAdded", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ByteArray::cairo_serialized_size(&meet_link);
            let bootcamp_id = match u64::cairo_deserialize(&event.data, data_offset) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "bootcamp_id",
                            "ActiveMeetLinkAdded", e
                        ),
                    );
                }
            };
            data_offset += u64::cairo_serialized_size(&bootcamp_id);
            let is_instructor = match bool::cairo_deserialize(&event.data, data_offset) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "is_instructor", "ActiveMeetLinkAdded", e
                        ),
                    );
                }
            };
            data_offset += bool::cairo_serialized_size(&is_instructor);
            let org_address = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "org_address",
                            "ActiveMeetLinkAdded", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &org_address,
                );
            return Ok(
                Event::ActiveMeetLinkAdded(ActiveMeetLinkAdded {
                    meet_link,
                    bootcamp_id,
                    is_instructor,
                    org_address,
                }),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("VideoLinkUploaded")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "VideoLinkUploaded")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let video_link = match cainome::cairo_serde::ByteArray::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "video_link",
                            "VideoLinkUploaded", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ByteArray::cairo_serialized_size(&video_link);
            let is_instructor = match bool::cairo_deserialize(&event.data, data_offset) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "is_instructor", "VideoLinkUploaded", e
                        ),
                    );
                }
            };
            data_offset += bool::cairo_serialized_size(&is_instructor);
            let org_address = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "org_address",
                            "VideoLinkUploaded", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &org_address,
                );
            let bootcamp_id = match u64::cairo_deserialize(&event.data, data_offset) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "bootcamp_id",
                            "VideoLinkUploaded", e
                        ),
                    );
                }
            };
            data_offset += u64::cairo_serialized_size(&bootcamp_id);
            return Ok(
                Event::VideoLinkUploaded(VideoLinkUploaded {
                    video_link,
                    is_instructor,
                    org_address,
                    bootcamp_id,
                }),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("BootcampRegistration")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "BootcampRegistration")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let org_address = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "org_address",
                            "BootcampRegistration", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &org_address,
                );
            let bootcamp_id = match u64::cairo_deserialize(&event.data, data_offset) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "bootcamp_id",
                            "BootcampRegistration", e
                        ),
                    );
                }
            };
            data_offset += u64::cairo_serialized_size(&bootcamp_id);
            return Ok(
                Event::BootcampRegistration(BootcampRegistration {
                    org_address,
                    bootcamp_id,
                }),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("RegistrationApproved")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "RegistrationApproved")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let student_address = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "student_address", "RegistrationApproved", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &student_address,
                );
            let bootcamp_id = match u64::cairo_deserialize(&event.data, data_offset) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "bootcamp_id",
                            "RegistrationApproved", e
                        ),
                    );
                }
            };
            data_offset += u64::cairo_serialized_size(&bootcamp_id);
            return Ok(
                Event::RegistrationApproved(RegistrationApproved {
                    student_address,
                    bootcamp_id,
                }),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("RegistrationDeclined")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "RegistrationDeclined")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let student_address = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "student_address", "RegistrationDeclined", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &student_address,
                );
            let bootcamp_id = match u64::cairo_deserialize(&event.data, data_offset) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "bootcamp_id",
                            "RegistrationDeclined", e
                        ),
                    );
                }
            };
            data_offset += u64::cairo_serialized_size(&bootcamp_id);
            return Ok(
                Event::RegistrationDeclined(RegistrationDeclined {
                    student_address,
                    bootcamp_id,
                }),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("AttendanceMarked")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "AttendanceMarked")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let org_address = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "org_address",
                            "AttendanceMarked", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &org_address,
                );
            let instructor_address = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "instructor_address", "AttendanceMarked", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &instructor_address,
                );
            let class_id = match u64::cairo_deserialize(&event.data, data_offset) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "class_id",
                            "AttendanceMarked", e
                        ),
                    );
                }
            };
            data_offset += u64::cairo_serialized_size(&class_id);
            return Ok(
                Event::AttendanceMarked(AttendanceMarked {
                    org_address,
                    instructor_address,
                    class_id,
                }),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("StudentsCertified")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "StudentsCertified")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let org_address = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "org_address",
                            "StudentsCertified", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &org_address,
                );
            let class_id = match u64::cairo_deserialize(&event.data, data_offset) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "class_id",
                            "StudentsCertified", e
                        ),
                    );
                }
            };
            data_offset += u64::cairo_serialized_size(&class_id);
            let student_addresses = match Vec::<
                cainome::cairo_serde::ContractAddress,
            >::cairo_deserialize(&event.data, data_offset) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "student_addresses", "StudentsCertified", e
                        ),
                    );
                }
            };
            data_offset
                += Vec::<
                    cainome::cairo_serde::ContractAddress,
                >::cairo_serialized_size(&student_addresses);
            return Ok(
                Event::StudentsCertified(StudentsCertified {
                    org_address,
                    class_id,
                    student_addresses,
                }),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("SponsorshipAddressSet")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "SponsorshipAddressSet")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let sponsor_contract_address = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "sponsor_contract_address", "SponsorshipAddressSet", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &sponsor_contract_address,
                );
            return Ok(
                Event::SponsorshipAddressSet(SponsorshipAddressSet {
                    sponsor_contract_address,
                }),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("OrganizationSponsored")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "OrganizationSponsored")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let organization_address = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "organization_address", "OrganizationSponsored", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &organization_address,
                );
            let sponsor_uri = match cainome::cairo_serde::ByteArray::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "sponsor_uri",
                            "OrganizationSponsored", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ByteArray::cairo_serialized_size(&sponsor_uri);
            let sponsorship_amount = match cainome::cairo_serde::U256::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "sponsorship_amount", "OrganizationSponsored", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::U256::cairo_serialized_size(
                    &sponsorship_amount,
                );
            return Ok(
                Event::OrganizationSponsored(OrganizationSponsored {
                    organization_address,
                    sponsor_uri,
                    sponsorship_amount,
                }),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("SponsorshipFundWithdrawn")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "SponsorshipFundWithdrawn")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let withdrawal_amount = match cainome::cairo_serde::U256::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "withdrawal_amount", "SponsorshipFundWithdrawn", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::U256::cairo_serialized_size(&withdrawal_amount);
            return Ok(
                Event::SponsorshipFundWithdrawn(SponsorshipFundWithdrawn {
                    withdrawal_amount,
                }),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("OrganizationSuspended")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "OrganizationSuspended")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let org_contract_address = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "org_contract_address", "OrganizationSuspended", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &org_contract_address,
                );
            let org_name = match cainome::cairo_serde::ByteArray::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "org_name",
                            "OrganizationSuspended", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ByteArray::cairo_serialized_size(&org_name);
            let suspended = match bool::cairo_deserialize(&event.data, data_offset) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "suspended",
                            "OrganizationSuspended", e
                        ),
                    );
                }
            };
            data_offset += bool::cairo_serialized_size(&suspended);
            return Ok(
                Event::OrganizationSuspended(OrganizationSuspended {
                    org_contract_address,
                    org_name,
                    suspended,
                }),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("BootCampSuspended")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "BootCampSuspended")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let org_contract_address = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "org_contract_address", "BootCampSuspended", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &org_contract_address,
                );
            let bootcamp_id = match u64::cairo_deserialize(&event.data, data_offset) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "bootcamp_id",
                            "BootCampSuspended", e
                        ),
                    );
                }
            };
            data_offset += u64::cairo_serialized_size(&bootcamp_id);
            let bootcamp_name = match cainome::cairo_serde::ByteArray::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "bootcamp_name", "BootCampSuspended", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ByteArray::cairo_serialized_size(
                    &bootcamp_name,
                );
            let suspended = match bool::cairo_deserialize(&event.data, data_offset) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "suspended",
                            "BootCampSuspended", e
                        ),
                    );
                }
            };
            data_offset += bool::cairo_serialized_size(&suspended);
            return Ok(
                Event::BootCampSuspended(BootCampSuspended {
                    org_contract_address,
                    bootcamp_id,
                    bootcamp_name,
                    suspended,
                }),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("OwnershipTransferred")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "OwnershipTransferred")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let previous_owner = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "previous_owner", "OwnershipTransferred", e
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &previous_owner,
                );
            let new_owner = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "new_owner",
                            "OwnershipTransferred", e
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &new_owner,
                );
            return Ok(
                Event::OwnableEvent(
                    OwnableComponentEvent::OwnershipTransferred(OwnershipTransferred {
                        previous_owner,
                        new_owner,
                    }),
                ),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("OwnershipTransferStarted")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "OwnershipTransferStarted")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let previous_owner = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "previous_owner", "OwnershipTransferStarted", e
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &previous_owner,
                );
            let new_owner = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "new_owner",
                            "OwnershipTransferStarted", e
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &new_owner,
                );
            return Ok(
                Event::OwnableEvent(
                    OwnableComponentEvent::OwnershipTransferStarted(OwnershipTransferStarted {
                        previous_owner,
                        new_owner,
                    }),
                ),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("Upgraded")
                .unwrap_or_else(|_| panic!("Invalid selector for {}", "Upgraded"))
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let class_hash = match cainome::cairo_serde::ClassHash::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "class_hash",
                            "Upgraded", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ClassHash::cairo_serialized_size(&class_hash);
            return Ok(
                Event::UpgradeableEvent(
                    UpgradeableComponentEvent::Upgraded(Upgraded { class_hash }),
                ),
            );
        }
        Err(format!("Could not match any event from keys {:?}", event.keys))
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub enum OwnableComponentEvent {
    OwnershipTransferred(OwnershipTransferred),
    OwnershipTransferStarted(OwnershipTransferStarted),
}
impl cainome::cairo_serde::CairoSerde for OwnableComponentEvent {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = std::option::Option::None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        match __rust {
            OwnableComponentEvent::OwnershipTransferred(val) => {
                OwnershipTransferred::cairo_serialized_size(val) + 1
            }
            OwnableComponentEvent::OwnershipTransferStarted(val) => {
                OwnershipTransferStarted::cairo_serialized_size(val) + 1
            }
            _ => 0,
        }
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        match __rust {
            OwnableComponentEvent::OwnershipTransferred(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&0usize));
                temp.extend(OwnershipTransferred::cairo_serialize(val));
                temp
            }
            OwnableComponentEvent::OwnershipTransferStarted(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&1usize));
                temp.extend(OwnershipTransferStarted::cairo_serialize(val));
                temp
            }
            _ => vec![],
        }
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let __f = __felts[__offset];
        let __index = u128::from_be_bytes(__f.to_bytes_be()[16..].try_into().unwrap());
        match __index as usize {
            0usize => {
                Ok(
                    OwnableComponentEvent::OwnershipTransferred(
                        OwnershipTransferred::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            1usize => {
                Ok(
                    OwnableComponentEvent::OwnershipTransferStarted(
                        OwnershipTransferStarted::cairo_deserialize(
                            __felts,
                            __offset + 1,
                        )?,
                    ),
                )
            }
            _ => {
                return Err(
                    cainome::cairo_serde::Error::Deserialize(
                        format!("Index not handle for enum {}", "OwnableComponentEvent"),
                    ),
                );
            }
        }
    }
}
impl TryFrom<starknet::core::types::EmittedEvent> for OwnableComponentEvent {
    type Error = String;
    fn try_from(
        event: starknet::core::types::EmittedEvent,
    ) -> Result<Self, Self::Error> {
        use cainome::cairo_serde::CairoSerde;
        if event.keys.is_empty() {
            return Err("Event has no key".to_string());
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("OwnershipTransferred")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "OwnershipTransferred")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let previous_owner = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "previous_owner", "OwnershipTransferred", e
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &previous_owner,
                );
            let new_owner = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "new_owner",
                            "OwnershipTransferred", e
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &new_owner,
                );
            return Ok(
                OwnableComponentEvent::OwnershipTransferred(OwnershipTransferred {
                    previous_owner,
                    new_owner,
                }),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("OwnershipTransferStarted")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "OwnershipTransferStarted")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let previous_owner = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "previous_owner", "OwnershipTransferStarted", e
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &previous_owner,
                );
            let new_owner = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "new_owner",
                            "OwnershipTransferStarted", e
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &new_owner,
                );
            return Ok(
                OwnableComponentEvent::OwnershipTransferStarted(OwnershipTransferStarted {
                    previous_owner,
                    new_owner,
                }),
            );
        }
        Err(format!("Could not match any event from keys {:?}", event.keys))
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub enum UpgradeableComponentEvent {
    Upgraded(Upgraded),
}
impl cainome::cairo_serde::CairoSerde for UpgradeableComponentEvent {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = std::option::Option::None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        match __rust {
            UpgradeableComponentEvent::Upgraded(val) => {
                Upgraded::cairo_serialized_size(val) + 1
            }
            _ => 0,
        }
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        match __rust {
            UpgradeableComponentEvent::Upgraded(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&0usize));
                temp.extend(Upgraded::cairo_serialize(val));
                temp
            }
            _ => vec![],
        }
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let __f = __felts[__offset];
        let __index = u128::from_be_bytes(__f.to_bytes_be()[16..].try_into().unwrap());
        match __index as usize {
            0usize => {
                Ok(
                    UpgradeableComponentEvent::Upgraded(
                        Upgraded::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            _ => {
                return Err(
                    cainome::cairo_serde::Error::Deserialize(
                        format!(
                            "Index not handle for enum {}", "UpgradeableComponentEvent"
                        ),
                    ),
                );
            }
        }
    }
}
impl TryFrom<starknet::core::types::EmittedEvent> for UpgradeableComponentEvent {
    type Error = String;
    fn try_from(
        event: starknet::core::types::EmittedEvent,
    ) -> Result<Self, Self::Error> {
        use cainome::cairo_serde::CairoSerde;
        if event.keys.is_empty() {
            return Err("Event has no key".to_string());
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("Upgraded")
                .unwrap_or_else(|_| panic!("Invalid selector for {}", "Upgraded"))
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let class_hash = match cainome::cairo_serde::ClassHash::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "class_hash",
                            "Upgraded", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ClassHash::cairo_serialized_size(&class_hash);
            return Ok(UpgradeableComponentEvent::Upgraded(Upgraded { class_hash }));
        }
        Err(format!("Could not match any event from keys {:?}", event.keys))
    }
}
impl<A: starknet::accounts::ConnectedAccount + Sync> orgsubgraph<A> {
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_admin(
        &self,
    ) -> cainome::cairo_serde::call::FCall<
        A::Provider,
        cainome::cairo_serde::ContractAddress,
    > {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_admin"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_all_bootcamp_classes(
        &self,
        org: &cainome::cairo_serde::ContractAddress,
        bootcamp_id: &u64,
    ) -> cainome::cairo_serde::call::FCall<A::Provider, Vec<u64>> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(org));
        __calldata.extend(u64::cairo_serialize(bootcamp_id));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!(
                "get_all_bootcamp_classes"
            ),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_all_bootcamps_on_platform(
        &self,
    ) -> cainome::cairo_serde::call::FCall<A::Provider, Vec<Bootcamp>> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!(
                "get_all_bootcamps_on_platform"
            ),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_all_org_bootcamps(
        &self,
        org_: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<A::Provider, Vec<Bootcamp>> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(org_));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_all_org_bootcamps"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_all_org_classes(
        &self,
        org_: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<A::Provider, Vec<Class>> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(org_));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_all_org_classes"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_all_org_info(
        &self,
    ) -> cainome::cairo_serde::call::FCall<A::Provider, Vec<Organization>> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_all_org_info"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_all_registration_request(
        &self,
        org_: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<A::Provider, Vec<Student>> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(org_));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!(
                "get_all_registration_request"
            ),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_bootcamp_active_meet_link(
        &self,
        org_: &cainome::cairo_serde::ContractAddress,
        bootcamp_id: &u64,
    ) -> cainome::cairo_serde::call::FCall<
        A::Provider,
        cainome::cairo_serde::ByteArray,
    > {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(org_));
        __calldata.extend(u64::cairo_serialize(bootcamp_id));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!(
                "get_bootcamp_active_meet_link"
            ),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_bootcamp_certification_status(
        &self,
        org: &cainome::cairo_serde::ContractAddress,
        bootcamp_id: &u64,
        student: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<A::Provider, bool> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(org));
        __calldata.extend(u64::cairo_serialize(bootcamp_id));
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(student));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!(
                "get_bootcamp_certification_status"
            ),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_bootcamp_info(
        &self,
        org_: &cainome::cairo_serde::ContractAddress,
        bootcamp_id: &u64,
    ) -> cainome::cairo_serde::call::FCall<A::Provider, Bootcamp> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(org_));
        __calldata.extend(u64::cairo_serialize(bootcamp_id));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_bootcamp_info"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_bootcamp_uploaded_video_link(
        &self,
        org_: &cainome::cairo_serde::ContractAddress,
        bootcamp_id: &u64,
    ) -> cainome::cairo_serde::call::FCall<
        A::Provider,
        Vec<cainome::cairo_serde::ByteArray>,
    > {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(org_));
        __calldata.extend(u64::cairo_serialize(bootcamp_id));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!(
                "get_bootcamp_uploaded_video_link"
            ),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_certified_student_bootcamp_address(
        &self,
        org: &cainome::cairo_serde::ContractAddress,
        bootcamp_id: &u64,
    ) -> cainome::cairo_serde::call::FCall<
        A::Provider,
        Vec<cainome::cairo_serde::ContractAddress>,
    > {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(org));
        __calldata.extend(u64::cairo_serialize(bootcamp_id));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!(
                "get_certified_student_bootcamp_address"
            ),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_class_attendance_status(
        &self,
        org: &cainome::cairo_serde::ContractAddress,
        bootcamp_id: &u64,
        class_id: &u64,
        student: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<A::Provider, bool> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(org));
        __calldata.extend(u64::cairo_serialize(bootcamp_id));
        __calldata.extend(u64::cairo_serialize(class_id));
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(student));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!(
                "get_class_attendance_status"
            ),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_instructor_info(
        &self,
        instructor: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<A::Provider, Vec<Instructor>> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(instructor));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_instructor_info"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_instructor_org_classes(
        &self,
        org_: &cainome::cairo_serde::ContractAddress,
        instructor: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<A::Provider, Vec<Class>> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(org_));
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(instructor));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!(
                "get_instructor_org_classes"
            ),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_instructor_part_of_org(
        &self,
        instructor: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<A::Provider, bool> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(instructor));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!(
                "get_instructor_part_of_org"
            ),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_new_admin(
        &self,
    ) -> cainome::cairo_serde::call::FCall<
        A::Provider,
        cainome::cairo_serde::ContractAddress,
    > {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_new_admin"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_org_info(
        &self,
        org_: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<A::Provider, Organization> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(org_));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_org_info"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_org_instructors(
        &self,
        org_: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<A::Provider, Vec<Instructor>> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(org_));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_org_instructors"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_org_sponsorship_balance(
        &self,
        organization: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<A::Provider, cainome::cairo_serde::U256> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(organization),
            );
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!(
                "get_org_sponsorship_balance"
            ),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_registered_bootcamp(
        &self,
        student: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<A::Provider, Vec<RegisteredBootcamp>> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(student));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_registered_bootcamp"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_specific_organization_registered_bootcamp(
        &self,
        org: &cainome::cairo_serde::ContractAddress,
        student: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<A::Provider, Vec<RegisteredBootcamp>> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(org));
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(student));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!(
                "get_specific_organization_registered_bootcamp"
            ),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_student_classes(
        &self,
        student: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<A::Provider, Vec<Class>> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(student));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_student_classes"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_student_info(
        &self,
        student_: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<A::Provider, Student> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(student_));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_student_info"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn is_bootcamp_suspended(
        &self,
        org_: &cainome::cairo_serde::ContractAddress,
        bootcamp_id: &u64,
    ) -> cainome::cairo_serde::call::FCall<A::Provider, bool> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(org_));
        __calldata.extend(u64::cairo_serialize(bootcamp_id));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("is_bootcamp_suspended"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn is_org_suspended(
        &self,
        org_: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<A::Provider, bool> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(org_));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("is_org_suspended"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn owner(
        &self,
    ) -> cainome::cairo_serde::call::FCall<
        A::Provider,
        cainome::cairo_serde::ContractAddress,
    > {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("owner"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn add_active_meet_link_getcall(
        &self,
        meet_link: &cainome::cairo_serde::ByteArray,
        bootcamp_id: &u64,
        is_instructor: &bool,
        org_address: &cainome::cairo_serde::ContractAddress,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ByteArray::cairo_serialize(meet_link));
        __calldata.extend(u64::cairo_serialize(bootcamp_id));
        __calldata.extend(bool::cairo_serialize(is_instructor));
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(org_address));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("add_active_meet_link"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn add_active_meet_link(
        &self,
        meet_link: &cainome::cairo_serde::ByteArray,
        bootcamp_id: &u64,
        is_instructor: &bool,
        org_address: &cainome::cairo_serde::ContractAddress,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ByteArray::cairo_serialize(meet_link));
        __calldata.extend(u64::cairo_serialize(bootcamp_id));
        __calldata.extend(bool::cairo_serialize(is_instructor));
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(org_address));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("add_active_meet_link"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn add_instructor_to_org_getcall(
        &self,
        instructor: &Vec<cainome::cairo_serde::ContractAddress>,
        org_name: &cainome::cairo_serde::ByteArray,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(
                Vec::<cainome::cairo_serde::ContractAddress>::cairo_serialize(instructor),
            );
        __calldata.extend(cainome::cairo_serde::ByteArray::cairo_serialize(org_name));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("add_instructor_to_org"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn add_instructor_to_org(
        &self,
        instructor: &Vec<cainome::cairo_serde::ContractAddress>,
        org_name: &cainome::cairo_serde::ByteArray,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(
                Vec::<cainome::cairo_serde::ContractAddress>::cairo_serialize(instructor),
            );
        __calldata.extend(cainome::cairo_serde::ByteArray::cairo_serialize(org_name));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("add_instructor_to_org"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn add_uploaded_video_link_getcall(
        &self,
        video_link: &cainome::cairo_serde::ByteArray,
        is_instructor: &bool,
        org_address: &cainome::cairo_serde::ContractAddress,
        bootcamp_id: &u64,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ByteArray::cairo_serialize(video_link));
        __calldata.extend(bool::cairo_serialize(is_instructor));
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(org_address));
        __calldata.extend(u64::cairo_serialize(bootcamp_id));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("add_uploaded_video_link"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn add_uploaded_video_link(
        &self,
        video_link: &cainome::cairo_serde::ByteArray,
        is_instructor: &bool,
        org_address: &cainome::cairo_serde::ContractAddress,
        bootcamp_id: &u64,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ByteArray::cairo_serialize(video_link));
        __calldata.extend(bool::cairo_serialize(is_instructor));
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(org_address));
        __calldata.extend(u64::cairo_serialize(bootcamp_id));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("add_uploaded_video_link"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn approve_registration_getcall(
        &self,
        student_address: &cainome::cairo_serde::ContractAddress,
        bootcamp_id: &u64,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(student_address),
            );
        __calldata.extend(u64::cairo_serialize(bootcamp_id));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("approve_registration"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn approve_registration(
        &self,
        student_address: &cainome::cairo_serde::ContractAddress,
        bootcamp_id: &u64,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(student_address),
            );
        __calldata.extend(u64::cairo_serialize(bootcamp_id));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("approve_registration"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn batch_certify_students_getcall(
        &self,
        org_: &cainome::cairo_serde::ContractAddress,
        bootcamp_id: &u64,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(org_));
        __calldata.extend(u64::cairo_serialize(bootcamp_id));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("batch_certify_students"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn batch_certify_students(
        &self,
        org_: &cainome::cairo_serde::ContractAddress,
        bootcamp_id: &u64,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(org_));
        __calldata.extend(u64::cairo_serialize(bootcamp_id));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("batch_certify_students"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn claim_admin_ownership_getcall(&self) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("claim_admin_ownership"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn claim_admin_ownership(&self) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("claim_admin_ownership"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn create_bootcamp_getcall(
        &self,
        org_name: &cainome::cairo_serde::ByteArray,
        bootcamp_name: &cainome::cairo_serde::ByteArray,
        nft_name: &cainome::cairo_serde::ByteArray,
        nft_symbol: &cainome::cairo_serde::ByteArray,
        nft_uri: &cainome::cairo_serde::ByteArray,
        num_of_class_to_create: &cainome::cairo_serde::U256,
        bootcamp_ipfs_uri: &cainome::cairo_serde::ByteArray,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ByteArray::cairo_serialize(org_name));
        __calldata
            .extend(cainome::cairo_serde::ByteArray::cairo_serialize(bootcamp_name));
        __calldata.extend(cainome::cairo_serde::ByteArray::cairo_serialize(nft_name));
        __calldata.extend(cainome::cairo_serde::ByteArray::cairo_serialize(nft_symbol));
        __calldata.extend(cainome::cairo_serde::ByteArray::cairo_serialize(nft_uri));
        __calldata
            .extend(cainome::cairo_serde::U256::cairo_serialize(num_of_class_to_create));
        __calldata
            .extend(cainome::cairo_serde::ByteArray::cairo_serialize(bootcamp_ipfs_uri));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("create_bootcamp"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn create_bootcamp(
        &self,
        org_name: &cainome::cairo_serde::ByteArray,
        bootcamp_name: &cainome::cairo_serde::ByteArray,
        nft_name: &cainome::cairo_serde::ByteArray,
        nft_symbol: &cainome::cairo_serde::ByteArray,
        nft_uri: &cainome::cairo_serde::ByteArray,
        num_of_class_to_create: &cainome::cairo_serde::U256,
        bootcamp_ipfs_uri: &cainome::cairo_serde::ByteArray,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ByteArray::cairo_serialize(org_name));
        __calldata
            .extend(cainome::cairo_serde::ByteArray::cairo_serialize(bootcamp_name));
        __calldata.extend(cainome::cairo_serde::ByteArray::cairo_serialize(nft_name));
        __calldata.extend(cainome::cairo_serde::ByteArray::cairo_serialize(nft_symbol));
        __calldata.extend(cainome::cairo_serde::ByteArray::cairo_serialize(nft_uri));
        __calldata
            .extend(cainome::cairo_serde::U256::cairo_serialize(num_of_class_to_create));
        __calldata
            .extend(cainome::cairo_serde::ByteArray::cairo_serialize(bootcamp_ipfs_uri));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("create_bootcamp"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn create_org_profile_getcall(
        &self,
        org_name: &cainome::cairo_serde::ByteArray,
        org_ipfs_uri: &cainome::cairo_serde::ByteArray,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ByteArray::cairo_serialize(org_name));
        __calldata
            .extend(cainome::cairo_serde::ByteArray::cairo_serialize(org_ipfs_uri));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("create_org_profile"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn create_org_profile(
        &self,
        org_name: &cainome::cairo_serde::ByteArray,
        org_ipfs_uri: &cainome::cairo_serde::ByteArray,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ByteArray::cairo_serialize(org_name));
        __calldata
            .extend(cainome::cairo_serde::ByteArray::cairo_serialize(org_ipfs_uri));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("create_org_profile"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn decline_registration_getcall(
        &self,
        student_address: &cainome::cairo_serde::ContractAddress,
        bootcamp_id: &u64,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(student_address),
            );
        __calldata.extend(u64::cairo_serialize(bootcamp_id));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("decline_registration"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn decline_registration(
        &self,
        student_address: &cainome::cairo_serde::ContractAddress,
        bootcamp_id: &u64,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(student_address),
            );
        __calldata.extend(u64::cairo_serialize(bootcamp_id));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("decline_registration"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn mark_attendance_for_a_class_getcall(
        &self,
        org_: &cainome::cairo_serde::ContractAddress,
        instructor_: &cainome::cairo_serde::ContractAddress,
        class_id: &u64,
        bootcamp_id: &u64,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(org_));
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(instructor_));
        __calldata.extend(u64::cairo_serialize(class_id));
        __calldata.extend(u64::cairo_serialize(bootcamp_id));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("mark_attendance_for_a_class"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn mark_attendance_for_a_class(
        &self,
        org_: &cainome::cairo_serde::ContractAddress,
        instructor_: &cainome::cairo_serde::ContractAddress,
        class_id: &u64,
        bootcamp_id: &u64,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(org_));
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(instructor_));
        __calldata.extend(u64::cairo_serialize(class_id));
        __calldata.extend(u64::cairo_serialize(bootcamp_id));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("mark_attendance_for_a_class"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn register_for_bootcamp_getcall(
        &self,
        org_: &cainome::cairo_serde::ContractAddress,
        bootcamp_id: &u64,
        student_uri: &cainome::cairo_serde::ByteArray,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(org_));
        __calldata.extend(u64::cairo_serialize(bootcamp_id));
        __calldata.extend(cainome::cairo_serde::ByteArray::cairo_serialize(student_uri));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("register_for_bootcamp"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn register_for_bootcamp(
        &self,
        org_: &cainome::cairo_serde::ContractAddress,
        bootcamp_id: &u64,
        student_uri: &cainome::cairo_serde::ByteArray,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(org_));
        __calldata.extend(u64::cairo_serialize(bootcamp_id));
        __calldata.extend(cainome::cairo_serde::ByteArray::cairo_serialize(student_uri));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("register_for_bootcamp"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn remove_instructor_from_org_getcall(
        &self,
        instructor: &cainome::cairo_serde::ContractAddress,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(instructor));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("remove_instructor_from_org"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn remove_instructor_from_org(
        &self,
        instructor: &cainome::cairo_serde::ContractAddress,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(instructor));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("remove_instructor_from_org"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn renounce_ownership_getcall(&self) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("renounce_ownership"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn renounce_ownership(&self) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("renounce_ownership"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn setSponsorShipAddress_getcall(
        &self,
        sponsor_contract_address: &cainome::cairo_serde::ContractAddress,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    sponsor_contract_address,
                ),
            );
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("setSponsorShipAddress"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn setSponsorShipAddress(
        &self,
        sponsor_contract_address: &cainome::cairo_serde::ContractAddress,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    sponsor_contract_address,
                ),
            );
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("setSponsorShipAddress"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn single_certify_student_getcall(
        &self,
        org_: &cainome::cairo_serde::ContractAddress,
        bootcamp_id: &u64,
        students: &cainome::cairo_serde::ContractAddress,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(org_));
        __calldata.extend(u64::cairo_serialize(bootcamp_id));
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(students));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("single_certify_student"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn single_certify_student(
        &self,
        org_: &cainome::cairo_serde::ContractAddress,
        bootcamp_id: &u64,
        students: &cainome::cairo_serde::ContractAddress,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(org_));
        __calldata.extend(u64::cairo_serialize(bootcamp_id));
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(students));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("single_certify_student"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn sponsor_organization_getcall(
        &self,
        organization: &cainome::cairo_serde::ContractAddress,
        uri: &cainome::cairo_serde::ByteArray,
        amt: &cainome::cairo_serde::U256,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(organization),
            );
        __calldata.extend(cainome::cairo_serde::ByteArray::cairo_serialize(uri));
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(amt));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("sponsor_organization"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn sponsor_organization(
        &self,
        organization: &cainome::cairo_serde::ContractAddress,
        uri: &cainome::cairo_serde::ByteArray,
        amt: &cainome::cairo_serde::U256,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(organization),
            );
        __calldata.extend(cainome::cairo_serde::ByteArray::cairo_serialize(uri));
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(amt));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("sponsor_organization"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn suspend_org_bootcamp_getcall(
        &self,
        org_: &cainome::cairo_serde::ContractAddress,
        bootcamp_id_: &u64,
        suspend: &bool,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(org_));
        __calldata.extend(u64::cairo_serialize(bootcamp_id_));
        __calldata.extend(bool::cairo_serialize(suspend));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("suspend_org_bootcamp"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn suspend_org_bootcamp(
        &self,
        org_: &cainome::cairo_serde::ContractAddress,
        bootcamp_id_: &u64,
        suspend: &bool,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(org_));
        __calldata.extend(u64::cairo_serialize(bootcamp_id_));
        __calldata.extend(bool::cairo_serialize(suspend));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("suspend_org_bootcamp"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn suspend_organization_getcall(
        &self,
        org_: &cainome::cairo_serde::ContractAddress,
        suspend: &bool,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(org_));
        __calldata.extend(bool::cairo_serialize(suspend));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("suspend_organization"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn suspend_organization(
        &self,
        org_: &cainome::cairo_serde::ContractAddress,
        suspend: &bool,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(org_));
        __calldata.extend(bool::cairo_serialize(suspend));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("suspend_organization"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn transfer_admin_getcall(
        &self,
        new_admin: &cainome::cairo_serde::ContractAddress,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(new_admin));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("transfer_admin"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn transfer_admin(
        &self,
        new_admin: &cainome::cairo_serde::ContractAddress,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(new_admin));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("transfer_admin"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn transfer_ownership_getcall(
        &self,
        new_owner: &cainome::cairo_serde::ContractAddress,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(new_owner));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("transfer_ownership"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn transfer_ownership(
        &self,
        new_owner: &cainome::cairo_serde::ContractAddress,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(new_owner));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("transfer_ownership"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn upgrade_getcall(
        &self,
        new_class_hash: &cainome::cairo_serde::ClassHash,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::ClassHash::cairo_serialize(new_class_hash));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("upgrade"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn upgrade(
        &self,
        new_class_hash: &cainome::cairo_serde::ClassHash,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::ClassHash::cairo_serialize(new_class_hash));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("upgrade"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn withdraw_sponsorship_fund_getcall(
        &self,
        amt: &cainome::cairo_serde::U256,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(amt));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("withdraw_sponsorship_fund"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn withdraw_sponsorship_fund(
        &self,
        amt: &cainome::cairo_serde::U256,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(amt));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("withdraw_sponsorship_fund"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
}
impl<P: starknet::providers::Provider + Sync> orgsubgraphReader<P> {
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_admin(
        &self,
    ) -> cainome::cairo_serde::call::FCall<P, cainome::cairo_serde::ContractAddress> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_admin"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_all_bootcamp_classes(
        &self,
        org: &cainome::cairo_serde::ContractAddress,
        bootcamp_id: &u64,
    ) -> cainome::cairo_serde::call::FCall<P, Vec<u64>> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(org));
        __calldata.extend(u64::cairo_serialize(bootcamp_id));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!(
                "get_all_bootcamp_classes"
            ),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_all_bootcamps_on_platform(
        &self,
    ) -> cainome::cairo_serde::call::FCall<P, Vec<Bootcamp>> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!(
                "get_all_bootcamps_on_platform"
            ),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_all_org_bootcamps(
        &self,
        org_: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<P, Vec<Bootcamp>> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(org_));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_all_org_bootcamps"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_all_org_classes(
        &self,
        org_: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<P, Vec<Class>> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(org_));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_all_org_classes"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_all_org_info(
        &self,
    ) -> cainome::cairo_serde::call::FCall<P, Vec<Organization>> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_all_org_info"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_all_registration_request(
        &self,
        org_: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<P, Vec<Student>> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(org_));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!(
                "get_all_registration_request"
            ),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_bootcamp_active_meet_link(
        &self,
        org_: &cainome::cairo_serde::ContractAddress,
        bootcamp_id: &u64,
    ) -> cainome::cairo_serde::call::FCall<P, cainome::cairo_serde::ByteArray> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(org_));
        __calldata.extend(u64::cairo_serialize(bootcamp_id));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!(
                "get_bootcamp_active_meet_link"
            ),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_bootcamp_certification_status(
        &self,
        org: &cainome::cairo_serde::ContractAddress,
        bootcamp_id: &u64,
        student: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<P, bool> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(org));
        __calldata.extend(u64::cairo_serialize(bootcamp_id));
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(student));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!(
                "get_bootcamp_certification_status"
            ),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_bootcamp_info(
        &self,
        org_: &cainome::cairo_serde::ContractAddress,
        bootcamp_id: &u64,
    ) -> cainome::cairo_serde::call::FCall<P, Bootcamp> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(org_));
        __calldata.extend(u64::cairo_serialize(bootcamp_id));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_bootcamp_info"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_bootcamp_uploaded_video_link(
        &self,
        org_: &cainome::cairo_serde::ContractAddress,
        bootcamp_id: &u64,
    ) -> cainome::cairo_serde::call::FCall<P, Vec<cainome::cairo_serde::ByteArray>> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(org_));
        __calldata.extend(u64::cairo_serialize(bootcamp_id));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!(
                "get_bootcamp_uploaded_video_link"
            ),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_certified_student_bootcamp_address(
        &self,
        org: &cainome::cairo_serde::ContractAddress,
        bootcamp_id: &u64,
    ) -> cainome::cairo_serde::call::FCall<
        P,
        Vec<cainome::cairo_serde::ContractAddress>,
    > {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(org));
        __calldata.extend(u64::cairo_serialize(bootcamp_id));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!(
                "get_certified_student_bootcamp_address"
            ),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_class_attendance_status(
        &self,
        org: &cainome::cairo_serde::ContractAddress,
        bootcamp_id: &u64,
        class_id: &u64,
        student: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<P, bool> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(org));
        __calldata.extend(u64::cairo_serialize(bootcamp_id));
        __calldata.extend(u64::cairo_serialize(class_id));
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(student));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!(
                "get_class_attendance_status"
            ),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_instructor_info(
        &self,
        instructor: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<P, Vec<Instructor>> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(instructor));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_instructor_info"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_instructor_org_classes(
        &self,
        org_: &cainome::cairo_serde::ContractAddress,
        instructor: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<P, Vec<Class>> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(org_));
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(instructor));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!(
                "get_instructor_org_classes"
            ),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_instructor_part_of_org(
        &self,
        instructor: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<P, bool> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(instructor));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!(
                "get_instructor_part_of_org"
            ),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_new_admin(
        &self,
    ) -> cainome::cairo_serde::call::FCall<P, cainome::cairo_serde::ContractAddress> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_new_admin"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_org_info(
        &self,
        org_: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<P, Organization> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(org_));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_org_info"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_org_instructors(
        &self,
        org_: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<P, Vec<Instructor>> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(org_));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_org_instructors"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_org_sponsorship_balance(
        &self,
        organization: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<P, cainome::cairo_serde::U256> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(organization),
            );
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!(
                "get_org_sponsorship_balance"
            ),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_registered_bootcamp(
        &self,
        student: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<P, Vec<RegisteredBootcamp>> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(student));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_registered_bootcamp"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_specific_organization_registered_bootcamp(
        &self,
        org: &cainome::cairo_serde::ContractAddress,
        student: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<P, Vec<RegisteredBootcamp>> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(org));
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(student));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!(
                "get_specific_organization_registered_bootcamp"
            ),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_student_classes(
        &self,
        student: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<P, Vec<Class>> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(student));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_student_classes"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_student_info(
        &self,
        student_: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<P, Student> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::ContractAddress::cairo_serialize(student_));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_student_info"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn is_bootcamp_suspended(
        &self,
        org_: &cainome::cairo_serde::ContractAddress,
        bootcamp_id: &u64,
    ) -> cainome::cairo_serde::call::FCall<P, bool> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(org_));
        __calldata.extend(u64::cairo_serialize(bootcamp_id));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("is_bootcamp_suspended"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn is_org_suspended(
        &self,
        org_: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<P, bool> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(org_));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("is_org_suspended"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn owner(
        &self,
    ) -> cainome::cairo_serde::call::FCall<P, cainome::cairo_serde::ContractAddress> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("owner"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
}
